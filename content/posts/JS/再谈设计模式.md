---
title: '再谈设计模式'
date: 2023-03-07T10:33:04+08:00
tags: [design patterns]
---

设计模式其实并不是多么高大尚的东西，都是码农届前辈积累下来的一些编程经验，在工作中可以说随处可见，作为前前端开发者，很有必要学习前辈的宝贵知识结晶，跟着 [desing-patterns](https://refactoringguru.cn/design-patterns) 再来回顾一下吧。

## 创建型模式

首先先了解下常用的工厂模式，又分为 「工厂方法模式」 和 「抽象工厂模式」。

##### 工厂方法模式

一句话：父类工厂提供创建对象的方法，由子类去决定实例化什么样的对象。

- 意义：可以在子类中重写工厂方法， 从而改变其创建「产品」的类型
- 注意：仅当「产品」具有共同的基类或者接口时， 子类才能返回不同类型的「产品」， 同时基类中的工厂方法还应将其返回类型声明为这一共有接口

> 工厂方法返回的对象被称作 “产品”

想象一下 Audi 的工厂，一开始只生产 A3，随着发展，后面又要生产 A4，A5....，如果每个产品都开一个新厂，那么代价太高，因为不同车型也可能使用相同的零件的。

<!-- 这个时候工厂方法就有用了，只需要提供一个 `order` 订单方法，告诉工厂目标车型，工厂根据车型差异化定制生产，比如不同的发动机型号。 -->

```TS
/* ---------- 生产类 -- 提供 「抽象工厂方法」 ---------- */
abstract class Produce {
  /**
   * 工厂方法
   */
  abstract produceAudi(): Car;
  /**
   * 重点是 --- 一些 「业务逻辑」 是依赖于工厂方法返回的产品
   */
  doSomethingWithCertainCar(): void {
    const car = this.produceAudi();
    car.run();
  }
}

/**
 * 实现工厂方法，实现不同的生产
 */
class ProduceA3 extends Produce {
  produceAudi() {
    return new Audi('A3', 'EA666');
  }
}
class ProduceA4 extends Produce {
  produceAudi() {
    return new Audi('A4', 'EA777');
  }
}

/* ---------- 产品类 -- 具体对象的创建和业务逻辑的重写 ---------- */
type Model = 'A3' | 'A4' | 'A5';
type Engine = 'EA888' | 'EA777' | 'EA666';

interface Car {
  model: Model;
  engine: Engine;
  run: () => void;
}

class Audi implements Car {
  model: Model;
  engine: Engine;
  constructor(model: Model, engine: Engine) {
    this.model = model;
    this.engine = engine;
  }
  /**
   * 这里简单写了下，实际上具体车型（产品）可以继承这个Audi基类，并重写具体的run方法实现。
   */
  run() {
    console.log(`${this.model} run with ${this.engine}`);
  }
}

const A3 = new ProduceA3();
A3.doSomethingWithCertainCar(); // A3 run with EA666
const A4 = new ProduceA4();
A4.doSomethingWithCertainCar(); // A4 run with EA777
```

##### 抽象工厂模式

```TS

```

##### 生成器模式

##### 原型模式

##### 单例模式

## 结构型模式

## 行为模式
