---
title: '再谈设计模式'
date: 2023-03-07T10:33:04+08:00
tags: [design patterns]
---

设计模式其实并不是多么高大尚的东西，都是码农届前辈积累下来的一些编程经验，在工作中可以说随处可见，作为前前端开发者，很有必要学习前辈的宝贵知识结晶，跟着 [desing-patterns](https://refactoringguru.cn/design-patterns) 再来回顾一下吧。

## 创建型模式

首先先了解下常用的工厂模式，又分为 「工厂方法模式」 和 「抽象工厂模式」。

##### 工厂方法模式

一句话：父类工厂提供创建对象的方法，由子类去决定实例化什么样的对象。

- 意义：可以在子类中重写工厂方法， 从而改变其创建「产品」的类型
- 注意：仅当「产品」具有共同的基类或者接口时， 子类才能返回不同类型的「产品」

> 工厂方法返回的对象被称作 “产品”

想象一下 Audi 的工厂，一开始只生产 A3，每台车出厂前都要做一次最高时速测试。随着发展，后面又要生产 A4，A5...省略不了的步骤是 -- 出厂前最高时速测试，很明显这是可以与 A3 共用测试车间，但同时又可以用不同的测试方案，这就可以利用起 「工厂方法」 模式了。

```TS
/* ---------- 生产类 -- 提供 「抽象工厂方法」 ---------- */
abstract class Produce {
  /**
   * 抽象工厂方法
   */
  abstract produceAudi(): Car;
  /**
   * 重点是:  1. 一些业务逻辑是依赖于工厂方法返回的产品
   *         2. 这些产品都有相同的业务逻辑
   */
  fastSpeed(): void {
    const car = this.produceAudi();
    car.run();
  }
}
/**
 * 实现具体工厂方法
 */
class ProduceA3 extends Produce {
  produceAudi() {
    return new A3();
  }
}
class ProduceA4 extends Produce {
  produceAudi() {
    return new A4();
  }
}

/* ---------- 产品类 -- 具体对象的创建和业务逻辑的重写 ---------- */
type Model = 'A3' | 'A4' | 'A5';
type Engine = 'EA888' | 'EA777' | 'EA666';

interface Car {
  model: Model;
  engine: Engine;
  run: () => void;
}

class A3 implements Car {
  model: Model = 'A3';
  engine: Engine = 'EA666';
  run(): void {
    console.log(
      `${this.model} runs with ${this.engine}， testing maximum speed..., wow is 200km/h`
    );
  }
}
class A4 implements Car {
  model: Model = 'A4';
  engine: Engine = 'EA888';
  run(): void {
    console.log(
      `${this.model} runs with ${this.engine}， testing maximum speed..., wow is 280km/h`
    );
  }
}

const A3ins = new ProduceA3();
A3ins.fastSpeed();
const A4ins = new ProduceA4();
A4ins.fastSpeed();
```

不用太在意具体的方法实现，抓住重点思想：

1. when use：**当相似业务逻辑依赖于不同类型的产品时，就可以使用「工厂方法模式」了**
2. how use：父类提供创建对象的工厂方法，子类可以重写覆盖

##### 抽象工厂模式

```TS

```

##### 生成器模式

##### 原型模式

##### 单例模式

## 结构型模式

## 行为模式
