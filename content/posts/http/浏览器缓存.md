---
title: '浏览器和http缓存'
date: 2022-10-06T23:19:05+08:00
tags: [http, browser]
---

缓存不论是在前端还是后端，都是一个重要的性能优化手段。  
Web 缓存种类： 数据库缓存，CDN 缓存，代理服务器缓存，浏览器缓存。

浏览器缓存的作用：每次发起 http 请求时，会先去检查浏览器缓存中是否有该请求的结果及缓存标识，如果可以使用就直接用了，就不用再去向服务器发起请求了，这样就能节约带宽，缓解服务器压力，提升前端性能；如果浏览器缓存没有或已过期再去向服务器请求，然后根据响应的缓存标识看看是否需要缓存。

## 缓存过程

##### 强缓存

缓存生效直接用浏览器缓存，不向服务器发起请求，返回状态码 200。

关键响应头：

- `cache-control`: max-age=2592000  
  是 `http1.1` 字段，优先级比 expires 高。主要有以下几个值：
  - public: 资源客户端和服务器都可以缓存
  - privite: 只有客户端可以缓存
  - no-cache: 客户端缓存资源，但是是否缓存需要经过协商缓存来验证
  - no-store: 不用缓存
  - max-age=<seconds>: 缓存保质期
- `expires`: Wed, 21 Oct 2015 07:28:00 GMT  
  是 `http1.0` 字段，指定过期日期。缺点是判断是否过期是用本地时间来判断的，本地时间是可以自己修改的。

浏览器遇见以上两个响应头时，就会把资源缓存到 `memory cache` 或 `disk cache` 中。  
存存储图像和网页等资源主要缓存在 `disk cache`，操作系统缓存文件等资源大部分都会缓存在 `memory cache` 中。具体操作浏览器自动分配，看谁的资源利用率不高就分给谁。

##### 协商缓存

协商缓存就是强缓存失效后，浏览器携带`缓存标识`向服务器发送请求，由`服务器根据缓存标识来决定`是否使用缓存的过程。缓存生效，返回 304。

关键响应头：

- `last-modified`: Wed, 19 Oct 2022 09:54:33 GMT  
  资源文件在服务器最后被修改的时间。
- `etag`: "634fc959-13ad03"  
  当前资源文件的一个唯一标识(由服务器生成)

关键请求头:

- `if-modified-since`: Wed, 19 Oct 2022 09:54:33 GMT  
  携带上次请求返回的 `Last-Modified` 值，服务器与请求资源的最后被修改时间作对比，如果大于 `if-modified-since`，则返回新资源，状态码为 200，否则用缓存，状态码为 304。
- `if-none-match`: W/"634fc959-13ad03"
  服务器资源的 etag 与 if-none-match 做对比，相同则返回 304，继续使用缓存。

> etag/if-none-match 优先级高于 last-modified/if-modified-since；同时存在则先验证 etag/if-none-match，一致的情况下，才会继续比对 last-modified。  
> 为什么需要 etag：1. 资源发生了周期性的修改，但最终内容未变，那么仍然是期望命中缓存的。2.last-modified 是秒级的，1 秒内的变化不会识别，此时希望是重新请求的。

## 缓存位置

缓存位置一般分为四类(按查找优先级)： `Service Worker --> Memory Cache --> Disk Cache --> Push Cache`。

##### Service Worker

是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。使用 Service Worker 的话，传输协议必须为 HTTPS。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。Service Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的。

##### Memory Cache

内存中的缓存，主要包含的是当前中页面中已经抓取到的资源，例如页面上已经下载的样式、脚本、图片等。读取内存中的数据肯定比磁盘快，内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。一旦我们关闭 Tab 页面，内存中的缓存也就被释放了。

##### Disk Cache

存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，比之 Memory Cache 胜在容量和存储时效性上。

##### Push Cache

Push Cache（推送缓存）是 HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被使用。它只在会话（Session）中存在，一旦会话结束就被释放，并且缓存时间也很短暂，在 Chrome 浏览器中只有 5 分钟左右，同时它也并非严格执行 HTTP 头中的缓存指令。

## 刷新

- F5 跳过强缓存，会检查协商缓存
- Command/Ctrl + F5，跳过强缓存和协商缓存

---

## cookie,localStorage,sessionStorage

|          | cookie                                                                           | localStorage             | sessionStorage                                     |
| -------- | -------------------------------------------------------------------------------- | ------------------------ | -------------------------------------------------- |
| 大小     | 4k                                                                               | 5M                       | 5M                                                 |
| 通信     | 每次请求携带在 http 请求头中                                                     | X                        | X                                                  |
| 作用域   | 与所有同源窗口均共享                                                             | 与所有同源窗口均共享     | 不在不同的浏览器窗口共享                           |
| 生命周期 | 一般由服务器生成，可以自定义失效时间，如果由浏览器生成，则默认为浏览器关闭时失效 | 只要不删除，就会一直存在 | 仅在当前会话下，当你关闭窗口或关闭浏览器时都会失效 |

重点说一下 cookie 的 secure 和 httpOnly 属性。

- httpOnly：顾名思义，就是不能通过 js 来获取 cookie，预防 XSS 攻击
- secure：http 和 https 都可以携带 cookie，加上此属性后，就只能在 https 中传输 cookie，更安全

## 参考

- [前端浏览器缓存知识梳理](https://juejin.cn/post/6947936223126093861)
- [彻底理解浏览器的缓存机制](https://juejin.cn/post/6844903593275817998)
