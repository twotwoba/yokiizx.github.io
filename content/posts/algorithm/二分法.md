---
title: '二分法'
date: 2023-01-03T11:24:54+08:00
tags: [algorithm]
---

其实是很容易理解的一种算法理论，从小学我们就懂，举个例子：考试，你去猜同学考了多少分，然后他只会告诉你猜的分数相比实际分数是高了还是低了，怎么猜最快得到答案？满分 100 分，如果他考了 80 分，假设他考所有分数的概率是一样的（忽略真是水平哈哈），那么一定是先猜 50 分，然后 75，87，81，80（命中）。

那么在算法中，我们针对的往往是具有**单调性**的（有序）场景，采用二分法逼近，能较快的提升查找速度，只不过二分法想要用好，一定要对**区间**和**边界条件**敏感。

用以下题目，来感受一下 👻

## 旋转数组系列

把这个系列放到前面，是为了更好的理解 **循环不变式** 和 **区间**。

##### [153. 寻找旋转排序数组中的最小值](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/description/)

给你一个元素值 互不相同 的数组 nums ，它原来是一个升序排列的数组，按照顺时针(从左往右)旋转 n 次，找出并返回其中的最小值。要求：时间复杂度 O(log n)

经典题，一眼过去，全是细节~

```JavaScript
/**
 * @param {number[]} nums
 * @return {number}
 */
var findMin = function (nums) {
    const n = nums.length
    let left = 0
    let right = n - 1  // 区间 [left, right] 如果用右开区间则不方便判断右值
    // 循环不变量对应区间为 [left, right)
    while(left < right) {
        const mid = left + ((right - left) >> 1) // 向下取整
        if(nums[mid] > nums[right]) {
            left = mid + 1 // left 可能和mid相等
        }else {
            right = mid // right
        }
    }
    return nums[left]
}
```

- 无重复、升序(单调递增)和 O(log n) 都在提示我们可以使用二分法来解决
- 思考旋转，导致的结果
  1. 左<中,中<右(min 在左,收缩右)
  2. 左<中,中>右(min 在右,收缩左)
  3. 左>中,中<右(min 在左,收缩右)，所以只比较中与右的关系即可
- 求的 mid，因为向下取整后偏向 left 一侧，所以 `left <= mid`、`mid < right`，为了保证循环不变量的恒等，left 将收缩为 mid + 1，right 将收缩为 mid
- 如果用 mid 和左比，那么 mid 需要先加一再向下取整，这样 mid 就更靠近右边的 right 了，然后先找出最大值，再向右偏一位即可

第二种做法：`while(left <= right)`

```JavaScript
/**
 * @param {number[]} nums
 * @return {number}
 */
var findMin = function (nums) {
    const n = nums.length
    let left = 0
    let right = n - 1
    // 循环不变式对应区间为  [left, right]
    while(left <= right) {
        const mid = left + ((right - left) >> 1) // 向下取整
        if(nums[mid] >= nums[right]) {
            left = mid + 1
        }else {
            right = mid
        }
    }
    return nums[right] // 当left==right时，即剩下最后一个元素时，一定是left=mid+1,right原地不动。而我们要取最后一个数据，所以返回nums[right]
}
```

> 优秀解析 [点击链接](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/solutions/126635/er-fen-cha-zhao-wei-shi-yao-zuo-you-bu-dui-cheng-z/)

##### [154. 寻找旋转排序数组中的最小值 II](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array-ii/)

这道题呢，也类似，只不过是存在重复的元素值，其实相比上一题无非就是多了一个 `nums[mid] === nums[right]` 的条件而已，上一题没有这个判断实际上是因为我们省略了，因为上一题中 nums[mid] 永远不可能等于 nums[right]。

```JavaScript

```

## 常规二分查找

##### [704.二分查找](https://leetcode.cn/problems/binary-search/)

```JavaScript
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var search = function(nums, target) {
    let left = 0
    // 其实这里初始化成 nums.length 也是能OK的，当收缩边界的时候就需要注意了， 见下一题
    let right = nums.length - 1
    // 循环不变量对应区间 [left, right)
    while(left < right) {
        const mid = left + (right - left >> 1)
        if(nums[mid] === target) {
            return mid
        }else if(nums[mid] < target) {
            left = mid + 1
        }else {
            right = mid -1
        }
    }
    return nums[left] === target ? left : -1
};
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var search = function(nums, target) {
    let left = 0
    let right = nums.length - 1
    while(left <= right) {
        const mid = left + (right - left >> 1)
        if(nums[mid] === target) {
            return mid
        }else if(nums[mid] < target) {
            left = mid + 1
        }else {
            right = mid -1
        }
    }
    return -1
};
```

如上，第一种和第二种仅仅是 循环不变式 发生了变化：

- 第一种：循环不变量对应区间为 `[left, right)`，结束条件是 `left === right`，如[2,2)就停止了，这意味着区间内可能会有元素没有遍历过，所以需要加一层兜底，比如数组只有一个数字的情况
- 第二种：循环不变量对应区间为 `[left, right]`，结束条件是 `left === right + 1`，如[3,2]才会停止，这意味着，区间内所有元素都被搜索过了

##### [剑指 Offer 53 - I. 在排序数组中查找数字 I](https://leetcode.cn/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/description/)

这是一道简单题，但是二分法如果运用不熟练，那可真的不简单~

```JavaScript
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var search = function(nums, target) {
    // 寻找出左右边界,然后相减即是区间了
    let left = 0
    let right = nums.length - 1 // 实际上这里是 nums.length 也ok, 因为是求左边界 [left, right) 对右边界无所谓
    while(left < right) {
        const mid = left + (right - left >> 1)
        if(nums[mid] === target) {
            right = mid // 寻找左边界, 按照[left, right), 所以 right = mid
        }else if(nums[mid] < target) {
            left = mid + 1
        }else {
            right = mid
        }
    }
    const l = left // 此处收缩右边界 right = mid 不会发生越界
    left = 0
    right = nums.length // 注意这里~~~ 因为是收缩左边界去找右边界了，由于循环不变量为[left,right), 所以初始区间右边界应该与之保持一致为 nums.length
    while(left < right) {
        const mid = left + (right - left >> 1)
        if(nums[mid] === target) {
            left = mid + 1 // 寻找右边界，收缩左边界，按照[left, right)，left = mid + 1
        }else if(nums[mid] < target) {
            left = mid + 1
        }else {
            right = mid
        }
    }
    const r = left - 1 < 0 ? 0 : left - 1 // mid是在搜索区间内的，而+1后的left不一定,结束条件是 left === right，由于是向右逼近，所以left应该-1
    if(l <= r && nums[l] === target && nums[r] === target) { // 防止压根没有
        return r - l + 1
    }
    return 0
};
```

怎么样，细节是不是拉满~~~  
所以强调一点，`循环不变量` 真的很重要！再就是收缩边界的方向和循环不变量区间结合起来反推出我们应该如何初始化初始区间，而不是根据初始化区间来确定循环不变量（这是本末倒置的，虽然我一开始也是这么取巧的 😂）。

TODO

## 个人总结

第一点，其实和二分没多大关系，就是在数组问题上，一定要对索引敏感，比如：

- 区间 `[a, b]`，那么 a~b (包含 a 和 b) 的长度为 `a - b + 1`
- 区间 `(a, b)`，那么 a~b (不包含 a 和 b) 的长度为 `a - b - 1`
- 区间 `[a, b) || (a, b]`，那么 a~b （不包含其中一个）的长度为 `a - b`

同样的，求索引也可以利用上述方法。

第二点，`while([condition])` 这里的 `condition` 是 `小于还是小于等于` 一定要搞清楚，有时候要从实际问题出发。

- 如果是 `<`，结束条件是 left === right，没啥好争议的，结果取 left 或 right 都一样
- 如果是 `<=`，结束条件是 left > right，注意 📢：这里就会有问题了，是 left 先越过 right 还是 right 先越过 left，这个是要搞清楚的，题目不同，也就不一样，但是会影响我们的结果，有时候会产生越界问题

第三点，在二分搜索中，while 循环时的循环条件称为**循环不变式**，它对应的区间称之为**循环不变量**， **_就是在 while 寻找中每一次边界的处理都要坚持根据区间的定义来操作_**，这直接决定了我们的逼近策略，very important！

## 参考

- [labuladong](https://labuladong.github.io/algo/di-yi-zhan-da78c/shou-ba-sh-48c1d/wo-xie-le--9c7a4/)
- [代码随想录](https://programmercarl.com/0704.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html#%E6%80%9D%E8%B7%AF)
