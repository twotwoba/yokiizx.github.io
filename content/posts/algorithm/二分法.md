---
title: '二分法'
date: 2023-01-03T11:24:54+08:00
tags: [algorithm]
---

其实是很容易理解的一种算法理论，从小学我们就懂，举个例子：考试，你去猜同学考了多少分，然后他只会告诉你猜的分数相比实际分数是高了还是低了，怎么猜最快得到答案？满分 100 分，如果他考了 80 分，假设他考所有分数的概率是一样的（忽略真是水平哈哈），那么一定是先猜 50 分，然后 75，87，81，80（命中）。

那么在算法中，我们针对的往往是具有**单调性**的（有序）场景，采用二分法逼近，能较快的提升查找速度，只不过二分法想要用好，一定要对**区间**和**边界条件**敏感。

用以下题目，来感受一下 👻

## 旋转数组系列

##### [153. 寻找旋转排序数组中的最小值](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/description/)

给你一个元素值 互不相同 的数组 nums ，它原来是一个升序排列的数组，按照顺时针(从左往右)旋转 n 次，找出并返回其中的最小值。要求：时间复杂度 O(log n)

经典题，一眼过去，全是细节~

```JavaScript
/**
 * @param {number[]} nums
 * @return {number}
 */
var findMin = function (nums) {
    const n = nums.length
    let left = 0
    let right = n - 1
    // 循环不变量对应区间为 [left, right)
    while(left < right) {
        const mid = left + ((right - left) >> 1) // 向下取整
        if(nums[mid] > nums[right]) {
            left = mid + 1
        }else {
            right = mid
        }
    }
    return nums[left]
}
```

- 无重复、升序(单调递增)和 O(log n) 都在提示我们可以使用二分法来解决
- 思考旋转，导致的结果 1.左<中,中<右(min 在左,收缩右); 2.左<中,中>右(min 在右,收缩左); 3.左>中,中<右(min 在左,收缩右)，所以只比较中与右的关系即可
- 求的 mid，因为取整后偏向 left 一侧，所以 `left <= mid`、`mid < right`，为了保证循环不变量的恒等，left 收缩为 mid + 1，right 收缩为 mid

第二种做法：`while(left <= right)`

```JavaScript
/**
 * @param {number[]} nums
 * @return {number}
 */
var findMin = function (nums) {
    const n = nums.length
    let left = 0
    let right = n - 1
    // 循环不变式对应区间为  [left, right]
    while(left <= right) {
        const mid = left + ((right - left) >> 1) // 向下取整
        if(nums[mid] >= nums[right]) {
            left = mid + 1
        }else {
            right = mid
        }
    }
    return nums[right]
}
```

> 优秀解析 [点击链接](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/solutions/126635/er-fen-cha-zhao-wei-shi-yao-zuo-you-bu-dui-cheng-z/)

## 个人总结

第一点，其实和二分没多大关系，就是在数组问题上，一定要对索引敏感，比如：

- 区间 `[a, b]`，那么 a~b (包含 a 和 b) 的长度为 `a - b + 1`
- 区间 `(a, b)`，那么 a~b (不包含 a 和 b) 的长度为 `a - b - 1`
- 区间 `[a, b) || (a, b]`，那么 a~b （不包含其中一个）的长度为 `a - b`

同样的，求索引也可以利用上述方法。

第二点，`while([condition])` 这里的 `condition` 是 `小于还是小于等于` 一定要搞清楚，有时候要从实际问题出发。

- 如果是 `<`，结束条件是 left === right，没啥好争议的，结果取 left 或 right 都一样
- 如果是 `<=`，结束条件是 left > right，注意 📢：这里就会有问题了，是 left 先越过 right 还是 right 先越过 left，这个是要搞清楚的，题目不同，也就不一样，但是会影响我们的结果，有时候会产生越界问题

第三点，在二分搜索中，while 循环时的循环条件称为**循环不变式**，它对应的区间称之为**循环不变量**， **_就是在 while 寻找中每一次边界的处理都要坚持根据区间的定义来操作_**，这直接决定了我们的逼近策略，very important！

## 参考

- [labuladong](https://labuladong.github.io/algo/di-yi-zhan-da78c/shou-ba-sh-48c1d/wo-xie-le--9c7a4/)
- [代码随想录](https://programmercarl.com/0704.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html#%E6%80%9D%E8%B7%AF)
