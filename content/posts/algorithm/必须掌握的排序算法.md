---
title: '必须掌握的排序算法'
date: 2022-09-23T14:42:51+08:00
---

## 比较排序

关于稳定性先给个结论：

- `O(n^2)` 里只有 `选择排序` 是不稳定的
- `O(nlogn)` 里只有 `归并排序` 是稳定的

### 冒泡排序

从左往右，两两比较，冒出极值。

```JavaScript
function bubble(arr) {
  for(let i = 0; i < arr.length - 1; i++) {
    let sorted = true
    for(let j = 0; j < arr.length - i - 1; j++) {
      if(arr[j] > arr[j + 1]) {
        swap(arr，j, j + 1)
        sorted = false
      }
    }
    if(sorted) break
  }
}
```

1. 外层循环控制遍历轮数，内层循环控制相邻元素相互比较；每次从头开始两两比较，排好序的在后头
2. -1 是因为与 `j + 1` 比较，最后一个无需再比；-i 是因为 前 i 个已经排好序了
3. 利用 sorted 来控制已经排好序了就提前结束遍历

### 插入排序

构建有序数列，从后往前找准位置插入

```JavaScript
function insert(arr) {
  for (let i = 1; i < arr.length; ++i) {
    let curr = i;
    let temp = arr[i]; // 用来去比较的
    while (curr > 0 && temp < arr[curr - 1]) {
      arr[curr] = arr[curr - 1]; // 往后挪
      curr--;
    }
    arr[curr] = temp; // 准确插入
  }
}
```

1. 假设第一个元素已经排好序了，从第二个元素(索引 1)开始遍历
2. 外层遍历设置指针和缓存数据，这一步很重要
3. 内层遍历是对已经排好序的队列遍历，与待插入的元素比较，凡是比它大的后退，腾位置

_补充一个更简单的写法：_

```java
/**
 * 插入排序
 *
 * @param arr
 */
public static void insertSort(int[] arr) {
    for (int i = 1; i < arr.length; i++) {
        for (int j = i - 1; j >= 0 && arr[j] > arr[j + 1]; --j) {
            swap(arr, j, j + 1);
        }
    }
}
```

### 选择排序

选择每个数作为极值（最大/最小），然后去和其之后的数比较，更新极值的指针，最后交换

```JavaScript
function select(arr) {
  for (let i = 0; i < arr.length - 1; i++) {
    let min = i
    for (let j = i + 1; j < arr.length; j++) {
      if (arr[j] < arr[min]) min = j
    }
    if (min !== i) swap(arr, i, min)
  }
}
```

1. 外层每个数被暂设为极值，最后一个数没必要再比
2. 与后方的数比，所以`j = i + 1`
3. 找出真正的极值后交换

### 快速排序

分治思想，关键是 `partition` 函数，也就是先分区，再分别进行快速排序

```JavaScript
// 类似二叉树的前序遍历
function quickSort(arr, l, r) {
  if(l >= r) return
  const index = partition(arr, l , r)
  quickSort(arr, l, index - 1)
  quickSort(arr, index + 1, r)
}

// 分区
function partition(arr, l, r) {
  // 随机选择基准，然后与头部交换，分割完成后，再放到正确的位置
  const randomIndex = l + Math.random() * (r - l) | 0
  const pivot = arr[randomIndex]
  // 把基准值交换到首部， 双指针 让 [l+1..r] 区间的元素对比 pivot 左右站队
  swap(arr, l, randomIndex)
  let i = l + 1
  let j = r
  while(i < j) {
    while(i < j && arr[i] <= pivot) i++
    while(i < j && arr[j] >= pivot) j--
    swap(arr, i, j)
  }
  // 结束条件是 i === j，此时指向的位置有可能是小于等于也有可能是大于等于基准值
  // 为了i/j所处位置一定是小于等于基准值, 所以加一层判断
  if (arr[i] > pivot) i--
  swap(arr, l, i)
  return i
}
```

1. 分治思想，快排类似前序遍历，需要先进行遍历，然后根据返回的分割线，再对左右分别遍历
2. 随机选择基准后和首位交换，然后借助指针，把小于等于的放左边，大于等于的放右边
3. 结束条件是 i===j，此时 j 有可能在大于等于 基准值上，为了保证与基准值交换的值一定小于等于基准值，需要加一层判断，如此才能把基准值放到准确的位置上。

> 另外一种是[填坑法](https://blog.51cto.com/u_14819316/3829823)，其实大同小异，只不过是在内存 while 的时候，满足条件就不断与基准值交换位置，类似于冒泡排序两两比较。

> 变体，`快速选择` 算法 ==> 快速排序的思想 + 二分的思想，见 lc215

### 希尔排序

插入排序的升级版，也叫缩小增量排序，用 gap 分组，没每个组内进行插入排序，当 gap 为 1 时，就排好序了，相比插入排序多了设定 gap 这一层最外部 for 循环

```JavaScript
function shellSort(nums) {
  for (let gap = arr.length >> 1; gap > 0; gap >>= 1) {   // 多了设定gap增量这一层
    for (let i = gap; i < arr.lenght; i++) {
      let curr = i
      let temp = nums[i]
      while (curr - gap >= 0 && nums[curr - gap] > temp) {
        nums[curr] = nums[curr - gap]
        curr -= gap
      }
      nums[curr] = temp
    }
  }
}
```

### 归并排序

```JavaScript
// 归并排序，类似二叉树的后序遍历
function mergeSort(nums) {
  const n = nums.length
  if (n === 1) return nums // 注意结束条件
  const mid = n >> 1
  const left = mergeSort(nums.slice(0, mid))
  const right =mergeSort(nums.slice(mid))
  return merge(left, right)
}

// 合并有序数组
function merge(left, right) {
  const res = []
  while (left.length && right.length) {
    left[0] < right[0] ? res.push(left.shift()) : res.push(right.shift())
  }
  if (left.length) res.push(...left)
  if (right.length) res.push(...right)
  return res
}
```

注意，在归并排序之前的排序方法都是在原数组基础上进行的，这里是返回的新数组，当然了，也有其他方式能实现，刚兴趣的可以了解，这里只是想介绍一下思想。

```java
/**
 * 归并排序
 *
 * @param arr
 * @param left
 * @param right
 */
public static void mergeSort(int[] arr, int left, int right) {
    if (left == right) return; // 结束条件
    int mid = left + (right - left >> 1);
    mergeSort(arr, left, mid);
    mergeSort(arr, mid + 1, right);
    merge(arr, left, mid, right);
}

public static void merge(int[] arr, int left, int mid, int right) {
    int[] help = new int[right - left + 1];

    int p1 = left;
    int p2 = mid + 1;
    int i = 0;
    while (p1 <= mid && p2 <= right) {
        help[i++] = arr[p1] < arr[p2] ? arr[p1++] : arr[p2++];
    }
    while (p1 <= mid) {
        help[i++] = arr[p1++];
    }
    while (p2 <= right) {
        help[i++] = arr[p2++];
    }

    for (int j = 0; j < help.length; j++) {
        arr[left + j] = help[j];
    }
}
```

### 堆排序

堆排序主要分两步走，第一步，初始化堆，对整体进行堆化（对非叶子节点进行堆化即可）；第二步，把堆顶和堆尾进行交换，这样最后一个数字就是排好序的，接着不断对试下的元素进行堆化。

```JavaScript
function heapSort(arr) {
  let n = arr.length;
  for (let i = arr.length >> 1; i >= 0; --i) heapify(arr, i, n); // 初始化堆化,非叶子节点
  for (let i = n - 1; i > 0; --i) {
    swap(arr, 0, i);
    n--;
    heapify(arr, 0, n);
  }
}
// 堆化的方法和优先队列的 down(i) 方法大体类似
function heapify(arr, i, size) {
  if (i === size - 1) return;
  const temp = i;
  let left = 2 * i + 1;
  let right = 2 * i + 2;
  if (left < size && arr[left] > arr[i]) i = left;
  if (right < size && arr[right] > arr[i]) i = right;
  if (i !== temp) {
    swap(arr, i, temp);
    heapify(arr, i, size);
  }
}
```

## 非比较排序

非比较排序的主要思想就是利用空间换时间，因此一般都会有使用前提条件。

### 计数排序

核心：`将数据作为另一个数组的键存储到另一个数组中`，所以一般来说只针对正整数，当然咱可以通过 + 一个数让所有的数都变成正数后再排序, 排序完成后再减去。

```JavaScript
function countSort(arr) {
  const count = []; // 记录数据的尺子, 把arr数字填充上去
  for (let i = 0; i < arr.length; ++i) {
    if (!count[arr[i]]) count[arr[i]] = 0;
    count[arr[i]]++;
  }
  let index = 0;
  for (let i = 0; i < count.length; ++i) { // 遍历尺子 修改原数组
    while (count[i]--) {
      arr[index++] = i;
    }
  }
}
```

时间复杂度 `O(n + k)`： n 个数, k 为范围。

### 桶排序

前提：假设输入数据服从均匀分布。

它利用函数的映射关系，将待排序元素分到有限的桶里，然后桶内元素再进行排序（可能是别的排序算法），最后将各个桶内元素输出得到一个有序数列

时间复杂度 `O(n)`

```JavaScript
function bucketSort(nums) {
  // 先确定桶的数量，要找出最大最小值，再根据 scope 求出桶数
  const scope = 3 // 每个桶的存储的范围
  const min = Math.min(...nums)
  const max = Math.max(...nums)
  const count = Math.floor((max - min) / scope) + 1
  const bucket = Array.from(new Array(count), _ => [])

  // 遍历数据，看应该放入哪个桶中
  for (const value of nums) {
    const index = ((value - min) / scope) | 0
    bucket[index].push(value)
  }

  const res = []
  // 对每个桶排序 然后放入结果集
  for (const item of bucket) {
    insert(item) // 插入排序
    res.push(...item)
  }
  return res
}
```

> 计数排序: 每个桶只存储单一键值  
> 桶排序: 每个桶存储一定范围的值

### 基数排序

留给评论区，😝~

---

如果你也对算法有兴趣，欢迎留言，拉您进群交流~👏🏻👏🏻👏🏻
