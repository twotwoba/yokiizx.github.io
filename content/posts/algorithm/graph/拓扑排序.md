---
title: '拓扑排序'
date: 2023-02-19T16:03:41+08:00
tags: [algorithm]
---

## 前置知识

##### 图的表现形式：

![图基础](https://raw.githubusercontent.com/yokiizx/picgo/main/images/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-2022-07-12.png)

```JavaScript
/** 0 -> 1, 0 -> 2; 1 -> 3; 2 -> 4 这么一副图的具体表现 */
// 邻接表
graph = [[1,2], [3], [4]]
// 邻接矩阵
graph = [
  [false, true, true, false, false],
  [false, false, false, true, false],
  [false, false, false, false, true]
]
```

邻接表和邻接矩阵各有优劣

- 邻接表，占用空间少，但是判断两个节点是否相邻，需要走一遍查找
- 邻接矩阵，矩阵中存在很多空洞，肯定需要更多的存储空间，但是判断两个节点是否相邻，直接 `matrix[i][j]` 判断是否为 true 即可

##### 图的遍历

```JavaScript
// 记录被遍历过的节点, 有环时需要这个来辅助一下
const visited = [] // boolean[];
// 记录从起点到当前节点的路径
const onPath = [] // boolean[];

/* 图遍历框架 dfs */
function traverse(graph, s) {
    if (visited[s]) return;
    // 经过节点 s，标记为已遍历
    visited[s] = true;
    // 做选择：标记节点 s 在路径上
    onPath[s] = true;
    for (const neighbor of graph.neighbors(s)) {
        traverse(graph, neighbor);
    }
    // 撤销选择：节点 s 离开路径
    onPath[s] = false;
}
```

> 注意 dfs 与回溯的差别：
>
> - 回溯做选择和撤销选择是在 for 循环内，对应选择、撤销选择的对象是「树枝」
> - DFS 做选择和撤销选择是在 for 循环外，对应选择、撤销选择的对象是「节点」

##### [797. 所有可能的路径](https://leetcode.cn/problems/all-paths-from-source-to-target/description/)

```JavaScript
/**
 * @param {number[][]} graph
 * @return {number[][]}
 */
 // 图的遍历
var allPathsSourceTarget = function(graph) {
    const res = []
    const path = []
    const traverse = (graph, s) => {
        path.push(s)
        if(s === graph.length - 1) {
            res.push([...path])
            // 可以在这里 return, 但是需要维护 path:
            // path.pop()
            // return
            // 不 return 也可以, 因为图中没有环, 不会无限递归
        }
        for(const v of graph[s]) {
            traverse(graph, v)
        }
        path.pop()
    }
    traverse(graph, 0)
    return res
};
```

## 拓扑排序定义

给定一个包含 n 个节点的有向图 G，我们给出它的节点编号的一种排列，如果满足：

> 对于图 G 中的任意一条有向边 (u, v)，u 在排列中都出现在 v 的前面。

那么称该排列是图 G 的「拓扑排序」，所以有两个特点：

- 图 G 不能有环，否则不能保证 u 一定在 v 之前
- 如果图 G 是有向无环图，那么它的拓扑排序可能不止一种

> 简单讲，把一个 有向无环图 转成 线性的排序 就叫 拓扑排序。直观点讲，把一幅图「拉平」后，这个「拉平」的图里面，所有箭头方向都是一致的。

##### [207.课程表](https://leetcode.cn/problems/course-schedule/description/?favorite=2cktkvj)

```JavaScript
/**
 * @param {number} numCourses
 * @param {number[][]} prerequisites
 * @return {boolean}
 */
 // 法一: 环检测, 当有环那就说明不能学习完成所有课程
 // 1. 依据题目进行建图, 使用邻接表
 // 2. 对图每个节点遍历
var canFinish = function(numCourses, prerequisites) {
    const buildGraph = () => {
        const graph = Array.from(Array(numCourses), () => [])
        for(let i = 0; i < prerequisites.length; ++i) {
            const [to, from] = prerequisites[i]
            graph[from].push(to)
        }
        return graph
    }
    const graph =  buildGraph()
    const path = new Array(numCourses).fill(false)
    const visited = new Array(numCourses).fill(false)
    let hasCycle = false
    const traverseGraph = (graph, s) => {
        if(path[s]) {
            hasCycle = true
            return
        }
        if(visited[s]) return
        visited[s] = true
        path[s] = true
        for(const v of graph[s]) {
            traverseGraph(graph, v)
        }
        path[s] = false
    }
    for (let i = 0; i < numCourses; i++) {
        // 遍历图中的所有节点
        traverseGraph(graph, i);
    }
    return !hasCycle
};
```

##### [210.课程表 II](https://leetcode.cn/problems/course-schedule-ii/)

```JavaScript

```
