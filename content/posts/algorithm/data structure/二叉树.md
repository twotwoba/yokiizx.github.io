---
title: 'äºŒå‰æ ‘'
date: 2024-01-15T21:01:56+08:00
lastmod: 2024-03-08
tags: []
series: [data structure]
categories: [algorithm]
---

## äºŒå‰æ ‘

```java
class Node<V> {
  V value;
  Node left;
  Node right;
}
```

### é€’å½’åº

```java
/**
 *        1
 *       / \
 *      2   3
 *     / \ / \
 *    4  5 6  7
 *
 * ä¸‹æ–¹ go å‡½æ•°å°±æ˜¯å¯¹è¿™æ£µäºŒå‰æ ‘çš„é€’å½’åºéå†
 * æ¯ä¸ªèŠ‚ç‚¹éƒ½ä¼šç»“æœ 3 æ¬¡ï¼Œåˆ†åˆ«åœ¨1ï¼Œ2ï¼Œ3ä½ç½®ï¼›å®é™…éå†é¡ºåºï¼š
 *
 * 1(1)ï¼Œ2(1)ï¼Œ4(1)ï¼Œ4(2)ï¼Œ4(3)ï¼Œ
 * 2(2)ï¼Œ5(1)ï¼Œ5(2)ï¼Œ5(3)ï¼Œ2(3)ï¼Œ
 * 1(2)ï¼Œ3(1)ï¼Œ6(1)ï¼Œ6(2)ï¼Œ6(3)ï¼Œ
 * 3(2)ï¼Œ7(1)ï¼Œ7(2)ï¼Œ7(3)ï¼Œ3(3)ï¼Œ1(3)
 *
 * å‰åºï¼ˆæ ¹å·¦å³ï¼ˆ1ï¼‰ï¼‰ç»“æœï¼š1ï¼Œ2ï¼Œ4ï¼Œ5ï¼Œ3ï¼Œ6ï¼Œ7
 * å‰åºï¼ˆå·¦æ ¹å³ï¼ˆ2ï¼‰ï¼‰ç»“æœï¼š4ï¼Œ2ï¼Œ5ï¼Œ1ï¼Œ6ï¼Œ3ï¼Œ7
 * å‰åºï¼ˆå·¦å³æ ¹ï¼ˆ3ï¼‰ï¼‰ç»“æœï¼š4ï¼Œ5ï¼Œ2ï¼Œ6ï¼Œ7ï¼Œ3ï¼Œ1
 */
public void go(Node head) {
  if(head == null) return;
  // 1
  go(head.left);
  // 2
  go(head.right);
  // 3
}
```

### å‰/ä¸­/ååºéå†

#### é€’å½’

é€’å½’æ–¹æ³•æ¯”è¾ƒå¥½ç†è§£ï¼Œå‰ä¸­ååºå°±æ˜¯åˆ†åˆ«åœ¨ä¸Šæ–¹ 1ï¼Œ2ï¼Œ3 å¯¹åº”çš„ä½ç½®è®¿é—®(æ‰“å°ç­‰æ“ä½œ)èŠ‚ç‚¹ã€‚

```java
public void traverse(Node head) {
  if(head == null) return;
  System.out.println(head.val); // å‰åºéå†
  traverse(head.left);
  System.out.println(head.val); // ä¸­åºéå†
  traverse(head.right);
  System.out.println(head.val); // ååºéå†
}
```

```java
// è·ç¦» lc.144
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> list = new ArrayList<>();
        if (root == null) return list;
        traverse(root, list);
        return list;
    }

    public void traverse(TreeNode root, List list) {
        if (root == null) return;
        list.add(root.val);
        traverse(root.left, list);
        traverse(root.right, list);
    }
}
```

#### è¿­ä»£

é€’å½’è½¬æˆè¿­ä»£ï¼Œæ ¸å¿ƒå°±æ˜¯è¦è‡ªå·±æ¨¡æ‹Ÿå‡ºæ ˆã€‚

##### å‰ lc.144

```java
public List<Integer> preorderTraversal(TreeNode root) {
    List<Integer> list = new ArrayList<>();
    if (root == null) return list;
    Stack<TreeNode> stack = new Stack<>();
    stack.push(root);
    while (!stack.empty()) {
        TreeNode top = (TreeNode) stack.pop();
        list.add(top.val);
        if (top.right != null) stack.push(top.right);
        if (top.left != null) stack.push(top.left);
    }
    return list;
}
```

> java çš„ Stack æ˜¯ Vector çš„ä¸€ä¸ªå­ç±»  
> java çš„ Queue æ˜¯ç”± LinkedList ç±»å®ç°äº† Queue æ¥å£

##### ä¸­ lc.94

```java
public List<Integer> inorderTraversal(TreeNode root) {
    List<Integer> list = new ArrayList<>();
    if (root == null) return list;
    Stack<TreeNode> stack = new Stack<>();
    while (!stack.empty() || root != null) {
        while (root != null) {
            stack.push(root);
            root = root.left;
        }
        TreeNode top = stack.pop();
        list.add(top.val);
        root = top.right;
    }
    return list;
}
```

##### å 1c.145

-   ä¸€ç§æ–¹æ³•æ˜¯ï¼ŒæŠŠå‰åºéå†çš„ stack ä¾æ¬¡å‡ºæ ˆæ—¶ä¸æ‰“å°ï¼Œè€Œæ˜¯è£…åˆ°å¦ä¸€ä¸ªæ ˆä¸­ï¼Œæœ€åå¯¹å¦ä¸€ä¸ªæ ˆä¾æ¬¡å‡ºæ ˆå°±æ˜¯ååºéå†çš„ç»“æœ
-   å¦ä¸€ç§æ–¹æ³•ç¨å¾®èŠ‚çº¦ç‚¹å†…å­˜ï¼Œä»ä¸Šé¢çš„äºŒå‰æ ‘é€’å½’åºæˆ‘ä»¬çŸ¥é“æ¯ä¸ªèŠ‚ç‚¹æœ‰ä¸‰æ¬¡éå†åˆ°çš„æƒ…å†µï¼ˆ1 æ¬¡è¿›å…¥ï¼Œ1 æ¬¡ä»å·¦èŠ‚ç‚¹è¿”å›ï¼Œ1 æ¬¡ä»å³èŠ‚ç‚¹è¿”å›ï¼‰ï¼Œ
    é‚£ä¹ˆï¼Œåœ¨èŠ‚ç‚¹å‡ºæ ˆçš„æ—¶å€™ï¼Œå…ˆåˆ¤å®šæ˜¯å¦æœ‰å³èŠ‚ç‚¹ï¼Œå¦‚æœæœ‰çš„è¯ï¼Œå°±å…ˆåˆ«å‡ºæ ˆäº†ï¼ŒæŠŠå³èŠ‚ç‚¹å…¥æ ˆï¼›é—®é¢˜æ˜¯å½“ä»å³èŠ‚ç‚¹å†å›åˆ°è¿™ä¸ªèŠ‚ç‚¹çš„æ—¶å€™ï¼Œ
    å°±éœ€è¦ä¸€ä¸ªé¢å¤–å˜é‡æ¥ç¡®å®šå³ä¾§çš„èŠ‚ç‚¹æ˜¯å¦å·²ç»è®¿é—®è¿‡äº†ã€‚

```java
public List<Integer> postorderTraversal(TreeNode root) {
    List<Integer> list = new ArrayList<>();
    if (root == null) return list;
    Stack<TreeNode> stack = new Stack<>();
    TreeNode visited = null;
    while (!stack.empty() || root != null) {
        while (root != null) {
            stack.push(root);
            root = root.left;
        }
        TreeNode top = stack.pop();
        if (top.right == null || top.right == visited) {
            list.add(top.val);
            visited = top;
        } else {
            stack.push(top);
            root = top.right;
        }
    }
    return list;
}
```

```js
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var postorderTraversal = function (root) {
    if (!root) return []
    const res = []
    const stack = []
    let visited = null
    while (stack.length || root) {
        while (root) {
            stack.push(root)
            root = root.left
        }
        const node = stack.pop()
        if (node.right !== null && node.right !== visited) {
            stack.push(node)
            root = node.right
        } else {
            res.push(node.val)
            visited = node
        }
    }
    return res
}
```

### å±‚åºéå† lc.102

æƒ³è¦å®ç°å±‚åºéå†çš„æ–¹æ³•éå¸¸å¤šï¼ŒDFS ä¹Ÿå¯ä»¥ï¼Œåªä¸è¿‡ä¸€èˆ¬ä¸è¿™ä¹ˆç”¨ï¼Œéœ€è¦æŒæ¡çš„æ˜¯ BFSã€‚BFS çš„åº”ç”¨éå¸¸å¹¿æ³›ï¼Œå…¶ä¸­åŒ…æ‹¬å¯»æ‰¾å›¾ä¸­çš„æœ€çŸ­è·¯å¾„ã€è§£å†³è¿·å®«é—®é¢˜ã€æ ‘çš„å±‚åºéå†ç­‰ç­‰ã€‚

åœ¨éå†è¿‡ç¨‹ä¸­ï¼ŒBFS ä½¿ç”¨ã€Œé˜Ÿåˆ—ã€æ¥å­˜å‚¨å·²ç»è®¿é—®çš„èŠ‚ç‚¹ï¼Œä»¥ç¡®ä¿æŒ‰ç…§å¹¿åº¦ä¼˜å…ˆçš„é¡ºåºè¿›è¡Œéå†ã€‚

```java
/**
 * å¦‚æœåªæ˜¯å¯¹é€å±‚ä»ä¸Šåˆ°ä¸‹ä»å·¦åˆ°å³æ‰“å°å‡ºèŠ‚ç‚¹ï¼Œæ˜¯å¾ˆå®¹æ˜“çš„ï¼Œä¸€ä¸ªqueueå°±è§£å†³äº†ã€‚
 * ä½†æ˜¯lc102æ˜¯è¦è¿”å›å½¢å¦‚ [[1],[2,3],...] è¿™æ ·List<List<Integer>>çš„æ•°æ®ç»“æ„ï¼Œé‚£ä¹ˆå°±éœ€è¦ä¸¤ä¸ªé˜Ÿåˆ—äº†
 * å½“ç„¶ï¼Œï¼ˆä¹Ÿæœ‰æ›´çœç©ºé—´çš„æ–¹æ³•ï¼ŒåŒæŒ‡é’ˆè®°ä½æ¯ä¸€å±‚çš„ç»“å°¾èŠ‚ç‚¹ï¼‰
 */
public List<List<Integer>> levelOrder(TreeNode root) {
    List<List<Integer>> list = new ArrayList<>();
    if (root == null) return list;
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    while (!queue.isEmpty()) {
        List<Integer> level = new ArrayList<>();
        int size = queue.size(); // å› ä¸ºqueueåœ¨å˜åŒ–ï¼Œæ‰€ä»¥éœ€è¦ç¼“å­˜ä¸€ä¸‹sizeã€‚å½“ç„¶ä¹Ÿå¯ä»¥ç”¨ä¸¤ä¸ªé˜Ÿåˆ—ï¼Œä¸æ–­äº¤æ¢æ¥å®ç°ï¼Œé‚£æˆ‘ä¸ªäººè§‰å¾—è¿™ç§æ–¹å¼æ›´å¥½ä¸€ç‚¹ã€‚
        for (int i = 0; i < size; i++) {
            TreeNode top = queue.poll();
            level.add(top.val);
            if (top.left != null) queue.offer(top.left);
            if (top.right != null) queue.offer(top.right);
        }
        list.add(level);
    }
    return list;
}
```

> ä»¥ä¸Šéƒ½æ˜¯è€ƒéªŒçš„åŸºç¡€ç¡¬ç¼–ç èƒ½åŠ›ï¼Œæ²¡ä»€ä¹ˆéš¾çš„ï¼Œå°±æ˜¯è¦å¤šç»ƒã€‚

---

## ç‰¹æ®ŠäºŒå‰æ ‘

### äºŒå‰æœç´¢æ ‘

å·¦ < æ ¹ < å³ï¼Œæ•´ä½“ä¸Šä¹Ÿæ˜¯ï¼šå·¦å­æ ‘æ‰€æœ‰å€¼ < æ ¹ < å³å­—æ ‘æ‰€æœ‰å€¼ã€‚

æ ¹æ® BST çš„ç‰¹æ€§ï¼Œåˆ¤å®šæ˜¯å¦ä¸º BST çš„æœ€ç®€å•çš„åŠæ³•æ˜¯ï¼Œä¸­åºéå†åï¼Œçœ‹æ˜¯å¦æŒ‰ç…§å‡åºæ’åºã€‚

```java
/**
 * åˆ¤å®šæ˜¯å¦ä¸ºäºŒå‰æœç´¢æ ‘ lc.98
 */
class Solution {
    long preValue = Long.MIN_VALUE;

    public boolean isValidBST(TreeNode root) {
        if (root == null) return true;
        boolean isLeftValid = isValidBST(root.left);
        if (!isLeftValid) return false; // æ³¨æ„è¿™é‡Œï¼Œæ‹¿åˆ°äº†å·¦æ ‘ä¿¡æ¯åï¼Œå°±å¯ä»¥åŠæ—¶åˆ¤æ–­äº†ï¼Œå½“ç„¶ä¹Ÿå¯ä»¥æ”¾åˆ°ååºçš„ä½ç½®åš~
        if (preValue == Long.MIN_VALUE) preValue = Long.MIN_VALUE; // // åŠ›æ‰£æµ‹è¯•ç”¨ä¾‹é‡Œè¶…è¿‡äº† int çš„èŒƒå›´ï¼Œæ‡‚å¾—æ€æƒ³å³å¯
        if (root.val <= preValue) return false;
        preValue = root.val;
        return isValidBST(root.right); // ä¸åœ¨ä¸­åºç«‹å³å¯¹å·¦æ ‘åˆ¤æ–­ï¼Œæ”¾åˆ°æœ€åä¹Ÿè¡Œï¼Œreturn isLeftValid && isValidBST(root.right);
    }
}
```

è¿™ä¸€é¢˜éå¸¸å¥½ï¼Œå¥½åœ¨å¯ä»¥å¸®åŠ©æˆ‘ä»¬æ›´å¥½çš„ç†è§£å½“é€’å½’ä¸­å‡ºç°è¿”å›å€¼çš„æƒ…å†µï¼š

-   é€’å½’ä¸­çš„ returnï¼Œæ˜¯ç»“æŸå½“å‰çš„è°ƒç”¨æ ˆï¼Œä»–å¹¶ä¸ä¼šé˜»å¡åç»­çš„é€’å½’æ ˆçš„æ‰§è¡Œ
-   æ¯ä¸€æ¬¡ return çš„ä¸œè¥¿æ˜¯ç”¨æ¥çœ‹å¯¹åç»­çš„ç¨‹åºäº§ç”Ÿçš„å½±å“ï¼Œåªéœ€åœ¨å¯¹åº”çš„å‰ä¸­ååºä½ç½®åšå¥½é€»è¾‘å¤„ç†å³å¯ï¼Œå…·ä½“é—®é¢˜ï¼Œå…·ä½“åˆ†æ

### å®Œå…¨äºŒå‰æ ‘

å°±æ˜¯å †é‚£æ ·å­çš„~æŒ¨ä¸ªä»ä¸Šåˆ°ä¸‹ï¼Œä»å·¦åˆ°å³æ’åˆ—åœ¨æ ‘ä¸­ã€‚æ¯«æ— ç–‘é—®ï¼Œå¾ˆå®¹æ˜“è”æƒ³åˆ°å±‚åºéå†ï¼Œé—®é¢˜æ˜¯æ€ä¹ˆåˆ¤æ–­å‘¢ï¼Ÿ

1. å½“éå†åˆ°ä¸€ä¸ªèŠ‚ç‚¹æ²¡æœ‰å·¦èŠ‚ç‚¹çš„æ—¶å€™ï¼Œå®ƒä¹Ÿä¸åº”è¯¥æœ‰å³èŠ‚ç‚¹
2. å½“éå†åˆ°ä¸€ä¸ªèŠ‚ç‚¹æ²¡æœ‰å³èŠ‚ç‚¹çš„æ—¶å€™ï¼Œåé¢æ‰€æœ‰çš„èŠ‚ç‚¹ï¼Œéƒ½ä¸åº”è¯¥æœ‰å­èŠ‚ç‚¹

```java
/**
 * åˆ¤å®šæ˜¯å¦ä¸ºå®Œå…¨äºŒå‰æ ‘ lc.958
 */
class Solution {
    public boolean isCompleteTree(TreeNode root) {
        List<Integer> list = new ArrayList<>();
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        boolean restShouldBeLeaf = false;
        while (!queue.isEmpty()) {
            TreeNode node = queue.poll();
            if (restShouldBeLeaf && (node.left != null || node.right != null)) {
                return false;
            }
            if (node.left == null && node.right != null) {
                return false;
            }
            if (node.left != null) {
                queue.offer(node.left);
            }
            if (node.right != null) {
                queue.offer(node.right);
            }
            if (node.right == null) {
                restShouldBeLeaf = true;
            }
        }
        return true;
    }
}
```

### æ»¡äºŒå‰æ ‘

æ»¡äºŒå‰æ ‘ï¼Œç‰¹æ€§ï¼šæ»¡äº†ï¼Œæ‰€ä»¥æ·±åº¦ä¸º `h`ï¼Œåˆ™èŠ‚ç‚¹æ•°ä¸º `2^h - 1`ã€‚

æ ¹æ®ç‰¹æ€§å»åšï¼Œå¾ˆç®€å•ï¼Œä¸€æ¬¡ dfs å°±èƒ½ç”¨ä¸¤ä¸ªå˜é‡ç»Ÿè®¡å‡ºæ·±åº¦å’ŒèŠ‚ç‚¹æ•°ã€‚

```java
/**
 * åˆ¤å®šæ˜¯å¦ä¸ºæ»¡äºŒå‰æ ‘
 */
int maxDeep = 0;
int deep = 0;
int count = 0;

public boolean isFullTree(TreeNode root) {
    traverse(root);
    return Math.pow(2, maxDeep) - 1 == count;
}

public void traverse(TreeNode root) {
    if (root == null) return;
    count++;
    deep++;
    maxDeep = Math.max(deep, maxDeep); // è¿™ä¸€æ­¥åœ¨å“ªéƒ½è¡Œï¼Œåªè¦åœ¨ deep++ å’Œ deep--ä¹‹é—´å°±éƒ½æ˜¯ ok çš„
    traverse(root.left);
    traverse(root.right);
    deep--;
}
```

### å¹³è¡¡äºŒå‰æ ‘

å¹³è¡¡äºŒå‰æ ‘çš„å·¦å³å­æ ‘çš„é«˜åº¦ä¹‹å·®ä¸è¶…è¿‡ 1ï¼Œ**ä¸”**å·¦å³å­æ ‘ä¹Ÿéƒ½æ˜¯å¹³è¡¡çš„ã€‚AVL æ ‘å’Œçº¢é»‘æ ‘éƒ½æ˜¯å¹³è¡¡äºŒå‰æ ‘ï¼Œé‡‡å–äº†ä¸åŒçš„æ–¹æ³•è‡ªåŠ¨ç»´æŒæ ‘çš„å¹³è¡¡ã€‚

```java
/**
 * åˆ¤å®šæ˜¯å¦ä¸ºå¹³è¡¡äºŒå‰æ ‘
 *
 * å®šä¹‰ä¸€ä¸ªè¿”å›ä½“ï¼Œæ˜¯éœ€è¦ä»å·¦å³å­æ ‘è·å–çš„ä¿¡æ¯
 */
class ReturnType {
    int height;
    boolean isBalance;
    public ReturnType(int height, boolean isBalance) {
        this.height = height;
        this.isBalance = isBalance;
    }
}

public static ReturnType isBalanceTree(TreeNode root) {
    if (root == null) {
        return new ReturnType(0, true);
    }
    /**
     * ç¬¬ä¸€æ­¥ï¼Œç”­ç®¡ä¸‰ä¸ƒäºŒåä¸€ï¼Œå…ˆæŠŠé€’å½’åºå†™ä¸Šæ¥
     */
    ReturnType left = isBalanceTree(root.left);
    ReturnType right = isBalanceTree(root.right);
    /**
     * ç¬¬äºŒæ­¥ï¼Œéœ€è¦å‘å·¦å³å­æ ‘æ‹¿ä¿¡æ¯äº†ã€‚
     */
    int height = Math.max(left.height, right.height);
    boolean isBalance = left.isBalance && right.isBalance && Math.abs(left.height - right.height) <= 1;
    return new ReturnType(height, isBalance);
}
```

å®šä¹‰å¥½ ReturnTypeï¼Œæ•´ä¸ªé€’å½’çš„ç®—æ³•å°±å¾ˆå®¹æ˜“å®ç°äº†ã€‚

## äºŒå‰æ ‘å¥—è·¯æŠ€å·§

å…¶å®ç»è¿‡ä¸€éƒ¨åˆ†çš„è®­ç»ƒï¼Œå¯ä»¥æ„Ÿå—åˆ°ååºéå†çš„â€œé­”æ³•äº†â€ï¼Œååºä½ç½®æˆ‘ä»¬å¯ä»¥è·å–åˆ°å·¦å­æ ‘å’Œå³å­æ ‘çš„ä¿¡æ¯ï¼Œå…³é”®åœ¨äºæˆ‘ä»¬éœ€è¦ä»€ä¹ˆä¿¡æ¯ï¼Œå…·ä½“é—®é¢˜ï¼Œå…·ä½“åˆ†æã€‚ç”±æ­¤ï¼Œå¯ä»¥è§£å†³å¾ˆå¤šé—®é¢˜ã€‚

è¯•ç€æŠŠä¸Šæ–¹æ²¡æœ‰ç”¨æ ‘å½¢ DP æ–¹å¼è§£å†³çš„æ–¹æ³•æ”¹å†™æˆæ ‘å½¢ DPã€‚

```java
/**
 * äºŒå‰æœç´¢æ ‘åˆ¤å®š
 *
 * æ€è€ƒéœ€è¦å‘å·¦å³å­æ ‘è·å–ä»€ä¹ˆä¿¡æ¯ï¼šå·¦ã€å³å­æ ‘æ˜¯å¦æ˜¯ bstï¼Œå·¦å­æ ‘æœ€å¤§å€¼ï¼Œå³å­æ ‘æœ€å°å€¼
 *
 * å¥½ï¼Œè¿™é‡Œå‡ºç°äº†åˆ†æ­§ï¼Œå‘å·¦æ ‘è¦æœ€å¤§ï¼Œå‘å³æ ‘è¦æœ€å°ï¼ŒåŒä¸€ä¸ªé€’å½’ä¸­è¿™å’‹å¤„ç†ï¼Ÿ
 *
 * ç­”æ¡ˆï¼š**åˆå¹¶å¤„ç†ï¼æˆ‘å…¨éƒ½è¦~**
 */
class ReturnType {
    boolean isBst;
    int max;
    int min;

    public ReturnType(boolean isBst, int max, int min) {
        this.isBst = isBst;
        this.max = max;
        this.min = min;
    }
}
public boolean isValidBST(TreeNode root) {
    return traverse(root).isBst;
}
public ReturnType traverse(TreeNode root) {
    if (root == null) return null; // æœ‰æœ€å¤§æœ€å°å€¼çš„æ—¶å€™ é‡åˆ° null è¿˜æ˜¯è¿”å› null å§ï¼Œè‹¥æ˜¯ç”¨è¯­è¨€è‡ªå¸¦çš„æœ€å¤§æœ€å°å€¼å¤„ç†æ¯”è¾ƒéº»çƒ¦
    ReturnType l = traverse(root.left);
    ReturnType r = traverse(root.right);
    long min = root.val, max = root.val;
    if (l != null) {
        min = Math.min(min, l.min);
        max = Math.max(max, l.max);
    }
    if (r != null) {
        min = Math.min(min, r.min);
        max = Math.max(max, r.max);
    }
    boolean isBst = true;
    if (l != null && (!l.isBst || l.max >= root.val)) {
        isBst = false;
    }
    if (r != null && (!r.isBst || r.min <= root.val)) {
        isBst = false;
    }
    return new ReturnType(isBst, min, max);
}
```

ä¸Šæ–¹çš„å†™æ³•å…¶å®è¿˜å¯ä»¥æ›´ç®€åŒ–ï¼Œè¿™ä¹ˆå†™æ˜¯ä¸ºäº†æ›´å¥½ç†è§£é€’å½’é‡Œçš„æœ€ä¼˜å­ç»“æ„ã€‚

```java
/**
 * æ»¡äºŒå‰æ ‘åˆ¤å®š ReturnType(nodes, deep)
 */
public ReturnType traverse(TreeNode root) {
    if (root == null) return new ReturnType(0, 0);
    ReturnType l = traverse(root.left);
    ReturnType r = traverse(root.right);
    int nodes = l.nodes + r.nodes + 1;
    int deep = Math.max(l.deep, r.deep) + 1;
    return new ReturnType(nodes, deep);
}
public boolean isFullTree(TreeNode root) {
    ReturnType res = traverse(root);
    System.out.println(res);
    return Math.pow(2, res.height) - 1 == res.nodes;
}
```

> æ³¨æ„ï¼Œè¿˜æ˜¯é‚£å¥è¯ï¼Œå…·ä½“é—®é¢˜å…·ä½“åˆ†æï¼Œè¿™ç§æŠ€å·§ï¼Œå¹¶ä¸é€‚åˆæ¯ç§äºŒå‰æ ‘çš„é—®é¢˜ï¼Œæ¯”å¦‚ï¼Œä¸€é¢—æ ‘ï¼Œè®©ä½ æ±‚æ•´ä¸ªæ ‘çš„ä¸­ä½æ•°ï¼Œæ ‘å½¢ DP çš„æ–¹å¼å°±åšä¸åˆ°ï¼Œå…¶å®å°±æ˜¯æ²¡æœ‰æœ€ä¼˜å­ç»“æ„ã€‚
> æ— æ³•è¿›è¡Œåˆ†è§£å­é—®é¢˜ç„¶åè¿›è¡Œååºæ ‘å½¢ dp çš„é—®é¢˜ï¼Œå°±åªèƒ½è¿›è¡Œéå†è§£å†³ï¼Œè¿™ç§ä¸€èˆ¬è¿ç”¨ã€Œå›æº¯ã€çš„ç®—æ³•æ€æƒ³ã€‚

---

## ç»ƒä¹ 

### lc.104 äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦ easy

é¢˜ç®€å•ï¼Œæ€æƒ³å¾ˆé‡è¦ã€‚

æ–¹æ³•ä¸€ï¼šæ·±åº¦ä¼˜å…ˆéå†ï¼Œå›æº¯

```js
/**
 * @param {TreeNode} root
 * @return {number}
 */
var maxDepth = function (root) {
    if (root == null) return 0
    let deep = 0
    let maxDeep = 0
    const traverse = root => {
        if (root == null) return
        deep++
        maxDeep = Math.max(maxDeep, deep)
        traverse(root.left)
        traverse(root.right)
        deep--
    }
    traverse(root)
    return maxDeep
}
```

æ–¹æ³•äºŒï¼šåˆ†è§£ä¸ºå­é—®é¢˜ï¼Œæ ‘å½¢ DP

```js
var maxDepth = function (root) {
    const traverse = root => {
        if (root == null) return 0
        const left = traverse(root.left)
        const right = traverse(root.right)
        // å½“å‰èŠ‚ç‚¹çš„æœ€å¤§æ·±åº¦ä¸º å·¦å³è¾ƒå¤§çš„é«˜åº¦åŠ ä¸Šè‡ªèº«çš„ 1
        return Math.max(left, right) + 1
    }
    return traverse(root)
}
```

### lc.543 äºŒå‰æ ‘çš„ç›´å¾„ easy

æ€è€ƒï¼šdfs éå†å¥½åƒæ²¡å•¥å¥½åŠæ³•ï¼Œä½†æ˜¯å¦‚æœåˆ†è§£ä¸ºå­é—®é¢˜ï¼Œå°±å¾ˆç®€å•äº†ï¼Œæ— éå°±æ˜¯å·¦è¾¹æœ€é•¿åŠ ä¸Šå³è¾¹æœ€é•¿å˜›~

```js
/**
 * @param {TreeNode} root
 * @return {number}
 */
var diameterOfBinaryTree = function (root) {
    if (root == null) return 0
    let res = 0
    const traverse = root => {
        if (root == null) return 0
        const l = traverse(root.left)
        const r = traverse(root.right)
        res = Math.max(l + r, res) // å°±æ˜¯å·¦å³å­æ ‘æœ€å¤§æ·±åº¦ä¹‹å’Œï¼Œä¿è¯æœ€å¤§
        return Math.max(l, r) + 1
    }
    traverse(root)
    return res
}
```

---

### lc.226 ç¿»è½¬äºŒå‰æ ‘ easy

```js
/**
 * @param {TreeNode} root
 * @return {TreeNode}
 */
var invertTree = function (root) {
    if (root == null) return null
    let p = root
    const traverse = root => {
        if (root == null) return null
        const l = traverse(root.left)
        const r = traverse(root.right)
        root.right = l
        root.left = r
        return root
    }
    traverse(p)
    return root
}
```

### lc.114 äºŒå‰æ ‘å±•å¼€ä¸ºé“¾è¡¨

```js
/**
 * @param {TreeNode} root
 * @return {void} Do not return anything, modify root in-place instead.
 */
var flatten = function (root) {
    if (root == null) return null
    const traverse = root => {
        if (root == null) return null
        let l = traverse(root.left)
        let r = traverse(root.right)
        if (l) {
            root.left = null
            root.right = l
            // æ²¡å•¥éš¾åº¦å°±æ˜¯æ³¨æ„æ‹¼æ¥è¿‡å»çš„æ—¶å€™å¯èƒ½æ˜¯ä¸€ä¸ªé“¾è¡¨
            while (l.right) {
                l = l.right
            }
            l.right = r
        }
        return root
    }
    traverse(root)
}
```

### lc.116 å¡«å……æ¯ä¸ªèŠ‚ç‚¹çš„ä¸‹ä¸€ä¸ªå³ä¾§èŠ‚ç‚¹æŒ‡é’ˆ

è§‚å¯Ÿå‘ç°è¿™é“é¢˜ï¼Œå·¦å³å­æ ‘çš„æ“ä½œéƒ½ä¸ä¸€æ ·ï¼Œæ‰€ä»¥ç”¨åˆ†è§£é—®é¢˜çš„æ–¹å¼æ²¡ä»€ä¹ˆæ€è·¯ã€‚

é‚£ä¹ˆéå†å‘¢ï¼Ÿé‚£å°±æ¯”è¾ƒç®€å•äº†ï¼Œå°±æ˜¯æŠŠ root.left -> root.right, root.right -> å…„å¼ŸèŠ‚ç‚¹çš„ leftï¼Œå…³é”®å°±åœ¨äºè¿™ä¸€æ­¥æ€ä¹ˆåšã€‚

```js
/**
 * @param {Node} root
 * @return {Node}
 */
var connect = function (root) {
    if (root == null) return root
    const traverse = (left, right) => {
        if (left == null || right == null) return
        left.next = right
        traverse(left.left, left.right)
        traverse(right.left, right.right)
        traverse(left.right, right.left)
    }
    traverse(root.left, root.right)
    return root
}
```

å®˜è§£ä¸­ï¼Œæ˜¯æ ¹æ®çˆ¶èŠ‚ç‚¹çš„ next æŒ‡é’ˆå»è·å–åˆ°çˆ¶èŠ‚ç‚¹çš„å…„å¼ŸèŠ‚ç‚¹ã€‚

### lcr.143 å­ç»“æ„åˆ¤æ–­

```js
/**
 * @param {TreeNode} A
 * @param {TreeNode} B
 * @return {boolean}
 */
var isSubStructure = function (A, B) {
    if (A == null || B == null) return false
    return traverse(A, B) || isSubStructure(A.left, B) || isSubStructure(A.right, B)
}

function traverse(nodeA, nodeB) {
    if (nodeB === null) return true
    if (nodeA === null || nodeA.val !== nodeB.val) return false
    const leftOk = traverse(nodeA.left, nodeB.left)
    const rightOk = traverse(nodeA.right, nodeB.right)
    return leftOk && rightOk
}
```

è¿™é“é¢˜è¿˜æ˜¯æŒºæœ‰æ„ä¹‰çš„ï¼Œæˆ‘ä¸€å¼€å§‹å†™ traverse å‡½æ•°çš„æ—¶å€™å°±é™·è¿›å»äº†ï¼Œè€æƒ³çš„å…ˆæ‰¾åˆ° `A === B` çš„èŠ‚ç‚¹ä¹‹åå†å¼€å§‹ä¸€ä¸€æ¯”å¯¹ï¼Œå®é™…ä¸Šå¯ä»¥é€šè¿‡ `isSubStructure(A.left, B)` å’Œ `isSubStructure(A.right, B)` æ¥å·§å¦™åœ°å¤„ç†ï¼Œåªè¦æœ‰ä¸€ä¸ªè¿”å›äº† trueï¼Œé‚£ä¹ˆå°±æ˜¯ ok çš„ã€‚

[åŠ›æ‰£å¤§ä½¬é¢˜è§£ï¼Œå†™çš„ä¸é”™](https://leetcode.cn/problems/shu-de-zi-jie-gou-lcof/solutions/791039/yi-pian-wen-zhang-dai-ni-chi-tou-dui-che-uhgs)

---

æ„é€ ç±»çš„é—®é¢˜ï¼Œä¸€èˆ¬éƒ½æ˜¯ä½¿ç”¨åˆ†è§£å­é—®é¢˜çš„æ–¹å¼å»è§£å†³ï¼Œä¸€ä¸ªæ ‘ = æ ¹+æ„é€ å·¦å­æ ‘+æ„é€ å³å­æ ‘ã€‚

### lc.654 æœ€å¤§äºŒå‰æ ‘

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {number[]} nums
 * @return {TreeNode}
 */
var constructMaximumBinaryTree = function (nums) {
    const build = (l, r) => {
        if (l > r) return null
        let maxIndex = l
        for (let i = l + 1; i <= r; ++i) {
            if (nums[i] > nums[maxIndex]) maxIndex = i
        }
        const node = new TreeNode(nums[maxIndex])
        node.left = build(l, maxIndex - 1)
        node.right = build(maxIndex + 1, r)
        return node
    }
    return build(0, nums.length - 1)
}
```

æŒ‰ç…§é¢˜ç›®è¦æ±‚ï¼Œå¾ˆå®¹æ˜“å®Œæˆï¼Œä½†æ˜¯æ­¤é¢˜çš„æœ€ä¼˜è§£æ˜¯ ã€Œå•è°ƒæ ˆã€ã€‚ã€‚ã€‚æˆ‘çš„å¤©å“ªï¼Œé¢˜ç›®ä¸æ˜¯è¦é€’å½’åœ°æ„å»ºå˜›ï¼Œè¿™è°æƒ³å¾—åˆ°å•Š ğŸ˜‚

### lc.105 ä»å‰åºä¸ä¸­åºéå†åºåˆ—æ„é€ äºŒå‰æ ‘

-   å‰åºéå†ï¼Œç¬¬ä¸€ä¸ªèŠ‚ç‚¹æ˜¯æ ¹èŠ‚ç‚¹
-   ä¸­åºéå†ï¼Œæ ¹èŠ‚ç‚¹å·¦ä¾§ä¸ºå·¦æ ‘ï¼Œå³ä¾§ä¸ºå³æ ‘

ä¸¤è€…ç»“åˆï¼Œä¸­åºä»å‰åºä¸­ç¡®å®šæ ¹èŠ‚ç‚¹ï¼Œå‰åºæ ¹æ®ä¸­åºæ ¹èŠ‚ç‚¹åˆ†å‰²å–åˆ°å·¦ä¾§æœ‰å­æ ‘çš„ sizeã€‚

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {number[]} preorder
 * @param {number[]} inorder
 * @return {TreeNode}
 */
var buildTree = function (preorder, inorder) {
    // ç¼“å­˜ä¸­åºçš„ç´¢å¼•
    const map = new Map()
    for (let i = 0; i < inorder.length; ++i) {
        map.set(inorder[i], i)
    }
    const build = (pl, pr, il, ir) => {
        if (pl > pr) return null // ä¸€å®šæ³¨æ„ä¸è¦å¿˜è®°é€’å½’ç»“æŸæ¡ä»¶ã€‚ã€‚ã€‚

        const rootVal = preorder[pl]
        const node = new TreeNode(rootVal)

        const inIndex = map.get(rootVal)
        const leftSize = inIndex - il
        node.left = build(pl + 1, pl + leftSize, il, inIndex - 1)
        node.right = build(pl + leftSize + 1, pr, inIndex + 1, ir)
        return node
    }
    return build(0, preorder.length - 1, 0, inorder.length - 1)
}
```

### lc.106 ä»ä¸­åºä¸ååºéå†åºåˆ—æ„é€ äºŒå‰æ ‘

ä¸ lc.105 é€»è¾‘ä¸€æ ·

```js
/**
 * @param {number[]} inorder
 * @param {number[]} postorder
 * @return {TreeNode}
 */
var buildTree = function (inorder, postorder) {
    const map = new Map()
    for (let i = 0; i < inorder.length; ++i) {
        map.set(inorder[i], i)
    }
    const build = (pl, pr, il, ir) => {
        if (pl > pr) return null

        const rootVal = postorder[pr]
        const node = new TreeNode(rootVal)

        const inIndex = map.get(rootVal)
        const leftSize = inIndex - il
        node.left = build(pl, pl + leftSize - 1, il, inIndex - 1)
        node.right = build(pl + leftSize, pr - 1, inIndex + 1, ir)
        return node
    }

    return build(0, postorder.length - 1, 0, inorder.length - 1)
}
```

### lc.889 æ ¹æ®å‰åºå’Œååºéå†æ„é€ äºŒå‰æ ‘

ä¸€ä¸ªå¤´æ˜¯æ ¹ï¼Œä¸€ä¸ªå°¾æ˜¯æ ¹ï¼Œæ— æ³•é€šè¿‡æ ¹èŠ‚ç‚¹æ¥åŒºåˆ†å·¦å³å­æ ‘äº†ï¼Œä½†æ˜¯ä»”ç»†è§‚å¯Ÿåï¼Œå¯ä»¥ä½¿ç”¨ pre çš„å·¦å­æ ‘çš„ç¬¬ä¸€ä¸ªèŠ‚ç‚¹æ¥åŒºåˆ†ã€‚

```js
/**
 * @param {number[]} preorder
 * @param {number[]} postorder
 * @return {TreeNode}
 */
var constructFromPrePost = function (preorder, postorder) {
    const map = new Map()
    for (let i = 0; i < postorder.length; ++i) {
        map.set(postorder[i], i)
    }

    const build = (pl, pr, tl, tr) => {
        if (pl > pr) return null
        if (pl === pr) return new TreeNode(preorder[pl]) // ! è¿™ä¸ªå…³é”®ç‚¹å¾ˆå®¹æ˜“æ¼æ‰, åªæœ‰ä¸€ä¸ªèŠ‚ç‚¹çš„æ—¶å€™

        const rootVal = preorder[pl]
        const root = new TreeNode(rootVal)

        const leftRootVal = preorder[pl + 1] // è¿™é‡Œå¾ˆå¯èƒ½ä¼šè¶Šç•Œï¼Œæ‰€ä»¥ä¸Šæ–¹éœ€è¦å•ç‹¬åˆ¤æ–­ pl == pr çš„æƒ…å†µ
        const leftRootIndex = map.get(leftRootVal)
        const leftSize = leftRootIndex - tl + 1

        root.left = build(pl + 1, pl + leftSize, tl, leftRootIndex)
        root.right = build(pl + leftSize + 1, pr, leftRootIndex + 1, tr - 1)
        return root
    }
    return build(0, preorder.length - 1, 0, postorder.length - 1)
}
```

> å‰åº+ååºè¿˜åŸçš„äºŒå‰æ ‘ä¸å”¯ä¸€ï¼Œæ¯”å¦‚ä¸€ç›´å·¦å­æ ‘å’Œä¸€ç›´å³å­æ ‘çš„å‰ååºéå†ç»“æœæ˜¯ä¸€æ ·çš„ã€‚

### LCR.152 éªŒè¯äºŒå‰æœç´¢æ ‘çš„ååºéå†åºåˆ—

äºŒå‰æœç´¢æ ‘ï¼šå·¦ > æ ¹ > å³ï¼Œç„¶è€Œç»™å‡ºçš„æ˜¯ååºçš„éå†ï¼Œæœ€å³è¾¹ä¸º æ ¹ï¼Œè§‚å¯Ÿå½’çº³ï¼šä»å·¦å¾€å³ç¬¬ä¸€ä¸ªå¤§äºæ ¹çš„ä¸ºå³å­æ ‘ï¼Œå¹¶ä¸”å…¶åéƒ½åº”å½“å¤§äºæ ¹ï¼Œç”±æ­¤æ‰¾åˆ°çªç ´å£ã€‚

```js
/**
 * @param {number[]} postorder
 * @return {boolean}
 */
var verifyTreeOrder = function (postorder) {
    if (postorder.length <= 1) return true

    const justify = (l, r) => {
        if (l >= r) return true

        const root = postorder[r]

        let i = l
        while (postorder[i] < root) i++
        let j = i
        while (j < r) {
            if (postorder[j++] < root) return false
        }

        return justify(l, i - 1) && justify(i, r - 1)
    }

    return justify(0, postorder.length - 1)
}
```

[åŠ›æ‰£ä¸é”™çš„è§£](https://leetcode.cn/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/solutions/383115/di-gui-he-zhan-liang-chong-fang-shi-jie-jue-zui-ha)

### lc.297 äºŒå‰æ ‘åºåˆ—åŒ–å’Œååºåˆ—åŒ–

```js
/**
 * Encodes a tree to a single string.
 * @param {TreeNode} root
 * @return {string}
 */
var serialize = function (root) {
    const traverse = root => {
        if (root == null) return '#_'
        let str = root.val + '_'
        str += traverse(root.left)
        str += traverse(root.right)
        return str
    }
    return traverse(root)
}

/**
 * Decodes your encoded data to tree.
 * @param {string} data
 * @return {TreeNode}
 */
var deserialize = function (data) {
    const arr = data.split('_')
    const generate = arr => {
        const val = arr.shift() // æ¯æ¬¡å¼¹å‡ºï¼Œå¯¹å‰©ä¸‹çš„é€’å½’å»ºæ ‘
        if (val === '#') return null
        const node = new TreeNode(val)
        node.left = generate(arr)
        node.right = generate(arr)
        return node
    }
    return generate(arr)
}
/**
 * Your functions will be called as such:
 * deserialize(serialize(root));
 */
```

<!-- lc.1008 ä¹Ÿæ˜¯æ„é€ é¢˜ -->

---

### lc.652 å¯»æ‰¾é‡å¤çš„å­æ ‘

å¸¸è§„èƒ½æƒ³åˆ°çš„æ–¹æ³•å°±æ˜¯åºåˆ—åŒ–ï¼Œä¸ºäº†ä¿è¯èƒ½åŒºåˆ†ç»“æ„ï¼Œä½¿ç”¨ `(,)` æ¥è¿›è¡Œåºåˆ—åŒ–ã€‚

```js
var findDuplicateSubtrees = function (root) {
    const map = new Map()
    const res = new Set()
    const dfs = node => {
        if (!node) {
            return ''
        }
        let str = ''
        str += node.val
        str += '('
        str += dfs(node.left)
        str += ')('
        str += dfs(node.right)
        str += ')'
        if (map.has(str)) {
            res.add(map.get(str))
        } else {
            map.set(str, node)
        }
        return str
    }
    dfs(root)
    return [...res]
}
```

è¿™é“é¢˜æœ‰ä¸ªæŠ€å·§æ˜¯ä½¿ç”¨ --- ä¸‰å…ƒç»„ (é•¿è§è¯†äº† ğŸ˜­)

```js
var findDuplicateSubtrees = function (root) {
    const map = new Map()
    const res = new Set()
    let idx = 0 // å…³é”®ç‚¹
    const dfs = node => {
        if (!node) {
            return 0
        }
        const tri = [node.val, dfs(node.left), dfs(node.right)] // ä¸‰å…ƒæ•°ç»„ [æ ¹èŠ‚ç‚¹çš„å€¼ï¼Œå·¦å­æ ‘åºå·ï¼Œå³å­æ ‘åºå·]
        const hash = tri.toString() // ç›¸åŒçš„å­—æ•° ä¸‰å…ƒæ•°ç»„å®Œå…¨ä¸€æ ·
        if (map.has(hash)) {
            const pair = map.get(hash)
            res.add(pair[0]) //
            return pair[1] //
        } else {
            map.set(hash, [node, ++idx]) //
            return idx
        }
    }
    dfs(root)
    return [...res]
}
// https://leetcode.cn/problems/find-duplicate-subtrees/solutions/1798953/xun-zhao-zhong-fu-de-zi-shu-by-leetcode-zoncw
```

### lc.236 æœ€ä½å…¬å…±ç¥–å…ˆ

å¸¸ç”¨çš„ git merge ç”¨çš„å°±æ˜¯è¿™é¢˜åŸç†ã€‚

```js
var lowestCommonAncestor = function (root, p, q) {
    let ans = null
    const dfs = node => {
        if (node == null) {
            return false
        }
        const leftRes = dfs(node.left)
        const rightRes = dfs(node.right)
        // æ›´å®¹æ˜“ç†è§£çš„åšæ³•ï¼Œå‘å·¦å³å­æ ‘è¦ä¿¡æ¯ï¼Œå®šä¹‰ dfs è¿”å›æ˜¯å¦å«æœ‰ p æˆ– q
        if (
            (leftRes && rightRes) ||
            ((node.val == p.val || node.val == q.val) && (leftRes || rightRes))
        ) {
            ans = node
            return
        }
        if (node.val == p.val || node.val == q.val || leftRes || rightRes) {
            return true
        }
        return false
    }
    dfs(root)
    return ans
}
```

```js
// æ›´åŠ æŠ½è±¡çš„ä»£ç 
/**
 * @param {TreeNode} root
 * @param {TreeNode} p
 * @param {TreeNode} q
 * @return {TreeNode}
 */
var lowestCommonAncestor = function (root, p, q) {
    const traverse = root => {
        if (root === null) return null
        if (root == p || root == q) return root
        const left = traverse(root.left)
        const right = traverse(root.right)
        if (left && right) return root
        return left ? left : right
    }
    return traverse(root)
}
```

### lc.235 äºŒå‰æœç´¢æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ

BST ä¸€èˆ¬éƒ½è¦å……åˆ†åˆ©ç”¨å®ƒçš„ç‰¹æ€§ã€‚

```js
/**
 * @param {TreeNode} root
 * @param {TreeNode} p
 * @param {TreeNode} q
 * @return {TreeNode}
 */
var lowestCommonAncestor = function (root, p, q) {
    let res = root
    while (true) {
        if (p.val > res.val && q.val > res.val) {
            res = res.right
        } else if (p.val < res.val && q.val < res.val) {
            res = res.left
        } else {
            break
        }
    }
    return res
}
```

### lc.285 äºŒå‰æ ‘ä¸­åºåç»§èŠ‚ç‚¹

è¿™é“é¢˜è¢«åŠ›æ‰£è®¾ä¸º vip é¢˜ç›®äº†ï¼Œå¯ä»¥çœ‹ lcr053ã€‚

é¡¾åæ€ä¹‰ï¼Œæœ€ç®€å•çš„ï¼Œæ ¹æ®é¢˜æ„ä¸­åºéå†å³å¯å¾—åˆ°ç­”æ¡ˆï¼š

```js
var inorderSuccessor = function (root, p) {
    const stack = []
    let nextIsRes = false
    while (stack.length || root) {
        while (root) {
            stack.push(root)
            root = root.left
        }
        const node = stack.pop()
        if (nextIsRes) return node
        if (node == p) nextIsRes = true
        if (node.right) root = node.right
    }
    return null
}
```

ä½†æ˜¯é¢è¯•æ€ä¹ˆå¯èƒ½è¿™ä¹ˆç®€å•å‘¢ï¼ŒæŒ‘é€‰å€™é€‰äººï¼Œå½“ç„¶éœ€è¦æ›´ä¼˜è§£ï¼Œå› æ­¤éœ€è¦æ¢ç´¢åˆ°æ–°çš„æ€è·¯

1. èŠ‚ç‚¹æœ‰å³ä¾§èŠ‚ç‚¹ï¼Œé‚£ä¹ˆæ ¹æ®ä¸­åºè§„åˆ™ï¼Œåç»§èŠ‚ç‚¹æ˜¯ å³ä¾§èŠ‚ç‚¹çš„æœ€å·¦è¾¹çš„å­èŠ‚ç‚¹
2. èŠ‚ç‚¹æ— å³ä¾§èŠ‚ç‚¹ï¼Œé‚£ä¹ˆæ ¹æ®ä¸­åºè§„åˆ™ï¼Œåç»­èŠ‚ç‚¹æ˜¯ çˆ¶èŠ‚ç‚¹ä¸­ç¬¬ä¸€ä¸ªä½œä¸ºå·¦å­èŠ‚ç‚¹çš„èŠ‚ç‚¹

å¦å¤–ï¼Œå¦‚æœé‡ä¸Šäº† BSTï¼Œåˆ™å¾€å¾€æœ‰éœ€è¦åˆ©ç”¨ä¸Š BST çš„æ€§è´¨

```js
/**
 * @param {TreeNode} root
 * @param {TreeNode} p
 * @return {TreeNode}
 */
var inorderSuccessor = function (root, p) {
    if (p.right) {
        let p1 = p.right
        while (p1 && p1.left) {
            p1 = p1.left
        }
        return p1
    }
    let res = null
    let p1 = root
    while (p1) {
        if (p1.val > p.val) {
            res = p1
            p1 = p1.left
        } else {
            p1 = p1.right
        }
    }
    return res
}
```

æ‹“å±•å§Šå¦¹é¢˜ï¼šå‡è®¾æ¯ä¸ªèŠ‚ç‚¹æœ‰ä¸€ä¸ª parent æŒ‡é’ˆæŒ‡å‘çˆ¶èŠ‚ç‚¹ï¼Œæ€ä¹ˆæ‰¾åç»§èŠ‚ç‚¹ï¼ŸåŸç†åŸºæœ¬ä¸€æ ·ï¼Œä¸åšè¿‡å¤šä»‹ç»ã€‚

---

æ¥ä¸‹æ¥æ˜¯äºŒå‰æœç´¢æ ‘çš„ç›¸å…³é¢˜ç›®
