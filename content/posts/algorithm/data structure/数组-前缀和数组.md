---
title: '数组-前缀和数组'
date: 2023-02-19T15:57:07+08:00
tags: [Array]
series: [data structure, trick]
categories: [algorithm]
---

## 概念

应用场景：在原始数组不会被修改的情况下，**快速、频繁查询某个区间的累加和**。

核心思路：开辟新数组 `preSum[i]` 来存储原数组 `nums[0..i-1] `的累加和，`preSum[0] = 0`。这样，当求原数组区间和就比较容易了，区间 `[i..j]` 的和等于 `preSum[j+1] - preSum[i]` 的结果值。

```JavaScript
const preSum = [0]
preSum[i] = preSum[i - 1] + nums[i - 1]
// 查询
preSum[r + 1] - preSum[l]

// 或者
const preSum = [nums[0]]
preSum[i] = preSum[i-1] + nums[i]
// 查询
preSum[r] - preSum[l-1] // 需要判断 l 为 0 的情况，直接返回 preSum[r]，这种的劣势是需要判断边界条件
```

### 构造：[lc.303 区域和检索-数组不可变](https://leetcode.cn/problems/range-sum-query-immutable/)

```JavaScript
/**
 * @param {number[]} nums
 */
var NumArray = function(nums) {
    this.preSum = [0] // preSum 首位为0 便于计算
    for(let i = 1; i <= nums.length; ++i) {
        this.preSum[i] = this.preSum[i - 1] + nums[i -1]
    }
};

/**
 * @param {number} left
 * @param {number} right
 * @return {number}
 */
NumArray.prototype.sumRange = function(left, right) {
    return this.preSum[right + 1] - this.preSum[left]
};

/**
 * Your NumArray object will be instantiated and called as such:
 * var obj = new NumArray(nums)
 * var param_1 = obj.sumRange(left,right)
 */
```

---

上方那种事官解给出的逻辑，下面这种可能更容易理解一些。

```js
/**
 * @param {number[]} nums
 */
var NumArray = function (nums) {
  this.preSums = [nums[0]]
  for (let i = 1; i < nums.length; ++i) {
    this.preSums[i] = this.preSums[i - 1] + nums[i]
  }
}

/**
 * @param {number} left
 * @param {number} right
 * @return {number}
 */
NumArray.prototype.sumRange = function (left, right) {
  if (left === 0) return this.preSums[right]
  return this.preSums[right] - this.preSums[left - 1]
}

/**
 * Your NumArray object will be instantiated and called as such:
 * var obj = new NumArray(nums)
 * var param_1 = obj.sumRange(left,right)
 */
```

### 构造：[lc.304 二维区域和检索-矩阵不可变](https://leetcode.cn/problems/range-sum-query-2d-immutable/)

```js
/**
 * @param {number[][]} matrix
 */
var NumMatrix = function (matrix) {
  const row = matrix.length
  const col = matrix[0].length
  this.sums = Array.from(Array(row + 1), () => Array(col + 1).fill(0))
  for (let i = 0; i < row; ++i) {
    for (let j = 0; j < col; ++j) {
      this.sums[i + 1][j + 1] =
        this.sums[i + 1][j] + this.sums[i][j + 1] - this.sums[i][j] + matrix[i][j]
    }
  }
  console.log(this.sums)
}

/**
 * @param {number} row1
 * @param {number} col1
 * @param {number} row2
 * @param {number} col2
 * @return {number}
 */
NumMatrix.prototype.sumRegion = function (row1, col1, row2, col2) {
  return (
    this.sums[row2 + 1][col2 + 1] -
    this.sums[row1][col2 + 1] -
    this.sums[row2 + 1][col1] +
    this.sums[row1][col1]
  )
}

/**
 * Your NumMatrix object will be instantiated and called as such:
 * var obj = new NumMatrix(matrix)
 * var param_1 = obj.sumRegion(row1,col1,row2,col2)
 */
```

### lc.523 连续的子数组和

这道题有点意思的，首先要知道一个数学知识：**同余定理：(a - b) % k == 0，则 a % k == b % k**。

根据题意，需要获取到的信息是：**(preSum[j] - preSum[i]) % k === 0**，如过存在则返回 true，那么就可以转化为：**寻找是否有两个前缀和能 % k 后，余数相同的问题了~**，那就很自然想到用哈希表来存储 `{余数：索引}`了，不然这题还真挺难想的~ 再一次 respect 数学！

```js
var checkSubarraySum = function (nums, k) {
  if (nums.length <= 1) return false
  const map = { 0: -1 }
  let preSum = 0
  for (let i = 0; i < nums.length; ++i) {
    preSum += nums[i]
    let b = preSum % k
    if (map[b] >= -1) {
      // 左开右闭区
      if (i - map[b] >= 2) {
        return true
      }
    } else {
      map[b] = i
    }
  }
  return false
}
```

**But！请注意，有坑**，上面的算法是没有问题的，然而数据量一下，且每个数都很大，则有可能有数字溢出的风险，力扣上有个测试用例就是这样的超出范围了~~~，所以这里需要用**余数去累加！**

```js
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {boolean}
 */
var checkSubarraySum = function (nums, k) {
  if (nums.length <= 1) return false
  // 注意这里：初始 key 为 0，value 为 -1，是为了计算第一个可以整除 k 的子数组长度
  const map = { 0: -1 }
  let remainder = 0
  for (let i = 0; i < nums.length; ++i) {
    remainder = (remainder + nums[i]) % k
    if (map[remainder] >= -1) {
      if (i - map[remainder] >= 2) {
        // 左开右闭区间
        return true
      }
    } else {
      map[remainder] = i
    }
  }
  return false
}
```

### lc.525 连续数组

绝，可以把 0 看成 -1，转为求前缀和为 0 的情况。实现上用一个 counter 变量即可。

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var findMaxLength = function (nums) {
  if (nums.length <= 1) return 0
  let max = 0
  const map = { 0: -1 }
  let counter = 0
  for (let i = 0; i < nums.length; ++i) {
    nums[i] === 1 ? ++counter : --counter
    // 哈希表中就有记录，表明此刻 区间前缀和之差 中 0 和 1 的数量相等
    // 举个例子 [1,1,1,0(-1)] 对应的前缀和为  1,2,3,2， 那么 (1, 3] 区间 1 个 0 和 1 个 1，长度为 3-1=2
    if (map[counter] >= -1) {
      max = Math.max(max, i - map[counter])
    } else {
      map[counter] = i
    }
  }
  return max
}
```

上面两题，有一丢丢类似，比如一种感觉，当通过哈希表来存储 `{need: 索引}` 时，都需要设定 map 初始为 `{0: -1}`，可以理解为**空的前缀的元素和为 0，空的前缀的结束下标为 −1**。再一个前缀和之差区间为左开右闭区间 `(i, j]`，所以长度为 j - i。

### [lc.528 按权重随机选择](https://leetcode.cn/problems/random-pick-with-weight/)

```JavaScript
/**
 * @param {number[]} w
 */
var Solution = function (w) {
  // 前缀和，然后随机数，看看落在前缀和的哪个区间，这样就保证了源数据的随机性带上了权重，当然需要配合二叉搜索左边界
  this.presum = new Array(w.length + 1)
  this.presum[0] = 0
  for (let i = 1; i < this.presum.length; ++i) {
    this.presum[i] = this.presum[i - 1] + w[i - 1]
  }
}

/**
 * @return {number}
 */
Solution.prototype.pickIndex = function () {
  const x = Math.floor(Math.random() * this.presum[this.presum.length - 1]) + 1
  return findLeftIndex(this.presum, x) - 1 // 前缀和的索引比原数组的索引都大1, 所以减掉
}

function findLeftIndex(presum, target) {
  let l = 1,
    r = presum.length // 前缀和首尾是占位0, 所以从1开始到最后一个索引结束(这里采用左闭右开)
  while (l < r) {
    const mid = l + ((r - l) >> 1)
    if (presum[mid] < target) {
      l = mid + 1
    } else {
      r = mid
    }
  }
  return l
}
```

### [lc.560 和为 k 的子数组](https://leetcode.cn/problems/subarray-sum-equals-k/)

```JavaScript
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var subarraySum = function(nums, k) {
    const preSum = [0]
    for(let i = 1; i <= nums.length; ++i) {
        preSum[i] = preSum[i-1] + nums[i-1]
    }
    let count = 0
    // 遍历出所有区间
    for(let i = 0; i < nums.length; ++i) {
        for(let j = i; j < nums.length; ++j) {
            preSum[j+1] - preSum[i] === k && ++count
        }
    }
    return count
};
```

这样做能得到正确结果，但是并不能 AC，时间复杂度 O(n^2)，不知道谁搞了个恶心的测试用例。。。会超时~

看了下题解，可以使用哈希表进行优化

```js
var subarraySum = function (nums, k) {
  const map = { 0: 1 }
  let preSum = 0
  let res = 0
  for (const num of nums) {
    preSum += num
    if (map[preSum - k]) {
      res += map[preSum - k]
    }

    if (map[preSum]) {
      map[preSum]++
    } else {
      map[preSum] = 1
    }
  }

  return res
}
```

### lc.724 寻找数组的中心下标 easy

```js

```

### lc.918 环形数组的最大和

```js

```

### lc.974 和可被 k 整除的子数组

```js

```

### 前缀积与后缀积

### [238. 除以自身以外的数组的乘积](https://leetcode.cn/problems/product-of-array-except-self/)

数组 nums，求除了 nums[i] 之外所有数字的乘积 === `preMulti * postMulti`

```js
/**
 * @param {number[]} nums
 * @return {number[]}
 */
var productExceptSelf = function (nums) {
  const n = nums.length
  const front = new Array(n)
  const end = new Array(n)
  front[0] = 1
  end[n - 1] = 1
  for (let i = 1; i < n; i++) {
    front[i] = front[i - 1] * nums[i - 1]
  }
  for (let i = n - 2; i >= 0; i--) {
    end[i] = end[i + 1] * nums[i + 1]
  }
  const res = []
  for (let i = 0; i < n; i++) {
    res[i] = front[i] * end[i]
  }
  return res
}
```

优化

```js
var productExceptSelf = function (nums) {
  // 优化 动态构造前缀和后缀 一次遍历, 让返回数组自身来承载
  const res = new Array(nums.length).fill(1)
  // 求出左侧所有乘积
  for (let i = 1; i < nums.length; i++) {
    res[i] = nums[i - 1] * res[i - 1]
  }
  // 右侧的乘积需要动态的求出, 倒叙遍历
  let r = 1
  for (let i = nums.length - 1; i >= 0; --i) {
    res[i] = res[i] * r
    r *= nums[i]
  }
  return res
}
```

> lc.327 lc.862 两道 hard 题，后续有时间再看看 😁
