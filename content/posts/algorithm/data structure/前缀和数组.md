---
title: '前缀和数组'
date: 2023-02-19T15:57:07+08:00
tags: [Array]
series: [data structure]
categories: [algorithm]
---

## 基础

应用场景：在原始数组不会被修改的情况下，**快速、频繁查询某个区间的累加和**。

核心思路：开辟新数组 `preSum[i]` 来存储原数组 `nums[0..i-1] `的累加和，`preSum[0] = 0`。这样，当求原数组区间和就比较容易了，区间 `[i..j]` 的和等于 `preSum[j+1] - preSum[i]` 的结果值。

```JavaScript
const preSum = [0]

preSum[i] = preSum[i - 1] + nums[i - 1]
```

### 构造：[303.区域和检索-数组不可变](https://leetcode.cn/problems/range-sum-query-immutable/)

```JavaScript
/**
 * @param {number[]} nums
 */
var NumArray = function(nums) {
    this.preSum = [0] // presum 首位为0 便于计算
    for(let i = 1; i <= nums.length; ++i) { // 遍历数组的每一个元素, 因为使用的是nums[i-1]
        this.preSum[i] = this.preSum[i - 1] + nums[i -1]
    }
};

/**
 * @param {number} left
 * @param {number} right
 * @return {number}
 */
NumArray.prototype.sumRange = function(left, right) {
    return this.preSum[right + 1] - this.preSum[left]
};

/**
 * Your NumArray object will be instantiated and called as such:
 * var obj = new NumArray(nums)
 * var param_1 = obj.sumRange(left,right)
 */
```

### 构造：[304. 二维区域和检索-矩阵不可变](https://leetcode.cn/problems/range-sum-query-2d-immutable/)

```js
/**
 * @param {number[][]} matrix
 */
var NumMatrix = function (matrix) {
  const m = matrix.length,
    n = matrix[0].length;
  if (m == 0 || n == 0) return;
  // 第一行,第一列填充为0方便计算
  this.presum = new Array(m + 1).fill(0).map(() => new Array(n + 1).fill(0));
  // 遍历presum,因为要填充到最后一个,所以是闭区间,使用小于等于，所以前缀和的索引超前matrix 1位
  for (let i = 1; i <= m; ++i) {
    for (let j = 1; j <= n; ++j) {
      // 计算矩阵[]0,0,i,j]，减去部分为重复部分
      this.presum[i][j] =
        this.presum[i - 1][j] +
        this.presum[i][j - 1] -
        this.presum[i - 1][j - 1] +
        matrix[i - 1][j - 1];
      // 当前块的区域和等于以matrix[0,0]为定点四个区域块的加减得来,其中左上角有一块会被加两次所以要减掉一次
    }
  }
};

NumMatrix.prototype.sumRegion = function (row1, col1, row2, col2) {
  return (
    this.presum[row2 + 1][col2 + 1] +
    this.presum[row1][col1] -
    this.presum[row1][col2 + 1] -
    this.presum[row2 + 1][col1]
  );
};
```

### 应用：[560.和为 k 的子数组](https://leetcode.cn/problems/subarray-sum-equals-k/)

```JavaScript
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var subarraySum = function(nums, k) {
    const preSum = [0]
    for(let i = 1; i <= nums.length; ++i) {
        preSum[i] = preSum[i-1] + nums[i-1]
    }
    let count = 0
    // 遍历出所有区间
    for(let i = 0; i < nums.length; ++i) {
        for(let j = i; j < nums.length; ++j) {
            preSum[j+1] - preSum[i] === k && ++count
        }
    }
    return count
};
```

### 进阶: [按权重随机选择](https://leetcode.cn/problems/random-pick-with-weight/)

```JavaScript
/**
 * @param {number[]} w
 */
var Solution = function (w) {
  // 前缀和，然后随机数，看看落在前缀和的哪个区间，这样就保证了源数据的随机性带上了权重，当然需要配合二叉搜索左边界
  this.presum = new Array(w.length + 1)
  this.presum[0] = 0
  for (let i = 1; i < this.presum.length; ++i) {
    this.presum[i] = this.presum[i - 1] + w[i - 1]
  }
}

/**
 * @return {number}
 */
Solution.prototype.pickIndex = function () {
  const x = Math.floor(Math.random() * this.presum[this.presum.length - 1]) + 1
  return findLeftIndex(this.presum, x) - 1 // 前缀和的索引比原数组的索引都大1, 所以减掉
}

function findLeftIndex(presum, target) {
  let l = 1,
    r = presum.length // 前缀和首尾是占位0, 所以从1开始到最后一个索引结束(这里采用左闭右开)
  while (l < r) {
    const mid = l + ((r - l) >> 1)
    if (presum[mid] < target) {
      l = mid + 1
    } else {
      r = mid
    }
  }
  return l
}
```

### 随机数小技巧

- 区间 `[i..j)` 随机数：`i + Math.random() * (j - i) | 0`
- 区间 `[i..j]` 随机数：`i + Math.random() * (j - i + 1) | 0`

> [JS 生成限定范围内随机整数](https://www.cnblogs.com/f6056/p/13362504.html)

## 思路衍生题: 前缀积与后缀积

### [238. 除以自身以外的数组的乘积](https://leetcode.cn/problems/product-of-array-except-self/)

数组 nums，求除了 nums[i] 之外所有数字的乘积 === `preMulti * postMulti`

```js
/**
 * @param {number[]} nums
 * @return {number[]}
 */
var productExceptSelf = function (nums) {
  const n = nums.length;
  const front = new Array(n);
  const end = new Array(n);
  front[0] = 1;
  end[n - 1] = 1;
  for (let i = 1; i < n; i++) {
    front[i] = front[i - 1] * nums[i - 1];
  }
  for (let i = n - 2; i >= 0; i--) {
    end[i] = end[i + 1] * nums[i + 1];
  }
  const res = [];
  for (let i = 0; i < n; i++) {
    res[i] = front[i] * end[i];
  }
  return res;
};
```

优化

```js
var productExceptSelf = function (nums) {
  // 优化 动态构造前缀和后缀 一次遍历, 让返回数组自身来承载
  const res = new Array(nums.length).fill(1);
  // 求出左侧所有乘积
  for (let i = 1; i < nums.length; i++) {
    res[i] = nums[i - 1] * res[i - 1];
  }
  // 右侧的乘积需要动态的求出, 倒叙遍历
  let r = 1;
  for (let i = nums.length - 1; i >= 0; --i) {
    res[i] = res[i] * r;
    r *= nums[i];
  }
  return res;
};
```
