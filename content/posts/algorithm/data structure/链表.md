---
title: 'é“¾è¡¨'
date: 2024-01-09T20:10:19+08:00
lastmod: 2024-03-04
series: [data structure]
categories: [algorithm]
---

## é“¾è¡¨

```java
class Node<V> {
  V value;
  Node next;
}
class Node<V> {
  V value;
  Node next;
  Node last;
}
```

> å¯¹äºé“¾è¡¨ç®—æ³•ï¼Œåœ¨é¢è¯•ä¸­ï¼Œä¸€å®šå°½é‡ç”¨åˆ°ç©ºé—´å¤æ‚åº¦æœ€å°çš„æ–¹æ³•ï¼ˆä¸ç„¶å‡­å•¥ç”¨å’±æ˜¯å§ ğŸ¶ï¼‰ã€‚

### é“¾è¡¨ã€Œæ¢å¤´ã€æƒ…å†µ

æ“ä½œé“¾è¡¨å‡ºç°ã€Œæ¢å¤´ã€çš„æƒ…å†µï¼Œå‡½æ•°çš„é€’å½’è°ƒç”¨å½¢å¼åº”è¯¥æ˜¯ `head = func(head.next)`ï¼Œæ‰€ä»¥å‡½æ•°åœ¨è®¾è®¡çš„æ—¶å€™å°±åº”è¯¥æœ‰ä¸€ä¸ª `Node` ç±»å‹çš„è¿”å›å€¼ï¼Œæ¯”å¦‚åè½¬é“¾è¡¨ã€‚

### å“¨å…µå®ˆå«

ã€Œå“¨å…µå®ˆå«ã€æ˜¯é“¾è¡¨ä¸­çš„å¸¸ç”¨æŠ€å·§ã€‚é€šè¿‡åœ¨é“¾è¡¨å¤´éƒ¨æˆ–å°¾éƒ¨æ·»åŠ å®ˆå«èŠ‚ç‚¹ï¼Œå¯ä»¥ç®€åŒ–å¯¹è¾¹ç•Œæƒ…å†µçš„å¤„ç†ã€‚

### é“¾è¡¨ä¸­å¸¸ç”¨çš„æŠ€å·§-å¿«æ…¢æŒ‡é’ˆ

#### æ‰¾åˆ°é“¾è¡¨çš„ä¸­ç‚¹ã€ä¸­ç‚¹å‰ä¸€ä¸ªã€ä¸­ç‚¹åä¸€ä¸ª

è¿™ä¸ªæ˜¯ç¡¬ç¼–ç èƒ½åŠ›ï¼Œéœ€è¦å¤§é‡ç»ƒä¹ æ‰“å¥½åŸºæœ¬åŠŸã€‚

```java
/**
 * å¥‡æ•°çš„ä¸­ç‚¹; å¶æ•°çš„ä¸­ç‚¹é å‰ä¸€ä½
 */
Node s = head;
Node f = head;
while (f.next != null && f.next.next != null) {
    s = s.next;
    f = f.next.next;
}

/**
 * å¥‡æ•°çš„ä¸­ç‚¹; å¶æ•°çš„ä¸­ç‚¹é åä¸€ä½ lc.876 easy
 */
while (f != null && f.next != null) {
    s = s.next;
    f = f.next.next;
}
```

å¦‚æœè¦è¿›ä¸€æ­¥ç»§ç»­åç§»ï¼Œä¿®æ”¹ f æˆ– s çš„åˆå§‹èŠ‚ç‚¹å³å¯ã€‚

æ³¨æ„ï¼šå› ä¸º f ä¸€æ¬¡èµ°ä¸¤æ­¥ï¼Œæ‰€ä»¥ï¼š

-   æƒ³è¦è·å–ä¸­ç‚¹å¾€å‰çš„èŠ‚ç‚¹ï¼Œä¿®æ”¹ f åˆå§‹èŠ‚ç‚¹æ—¶ `f=head.next.next`ï¼Œä¸¤ä¸ª next æ‰ä¼šè®©ç»“æœå¾€å‰åç§»ä¸€æ­¥
-   æƒ³è¦è·å–ä¸­ç‚¹å¾€åçš„èŠ‚ç‚¹ï¼Œä¿®æ”¹ s çš„åˆå§‹èŠ‚ç‚¹ `s=head.next`ï¼Œä¸€ä¸ª next å°±å¯ä»¥è®©ç»“æœå¾€ååç§»ä¸€æ­¥

### ç»ƒä¹ 

#### lc.2 ä¸¤æ•°ç›¸åŠ 

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
var addTwoNumbers = function (l1, l2) {
    let dummy = new ListNode(-1)
    let p = dummy

    let p1 = l1,
        p2 = l2
    let carry = 0
    while (p1 || p2) {
        let a = p1 ? p1.val : 0
        let b = p2 ? p2.val : 0
        let sum = a + b + carry
        carry = (sum / 10) | 0
        p.next = new ListNode(sum % 10)
        p = p.next
        p1 = p1 ? p1.next : null
        p2 = p2 ? p2.next : null
    }
    if (carry) {
        p.next = new ListNode(carry)
    }
    return dummy.next
}
```

#### lc.19 åˆ é™¤é“¾è¡¨å€’æ•°ç¬¬ N ä¸ªèŠ‚ç‚¹

```js
/**
 * @param {ListNode} head
 * @param {number} n
 * @return {ListNode}
 */
var removeNthFromEnd = function (head, n) {
    let p = head
    while (n--) {
        p = p.next
    }
    let p2 = head
    while (p) {
        p = p.next
        p2 = p2.next
    }
    p2.next = p2.next.next
    return head
}
```

lc.2 å’Œ lc.19 æ˜¯ dummy å®ˆå«èŠ‚ç‚¹çš„æœ€ä½³å®è·µäº†ï¼Œä¸€ä¸ªæ˜¯æ–°å¢ï¼Œä¸€ä¸ªæ˜¯åˆ é™¤ã€‚

<!-- å€’æ•°ç¬¬ N ä¸ªï¼Œæ˜¯æ­£æ•°ç¬¬ len - N + 1 ä¸ª -->

---

#### lc.21 åˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨ easy

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} list1
 * @param {ListNode} list2
 * @return {ListNode}
 */
var mergeTwoLists = function (list1, list2) {
    let dummy = new ListNode(-1)
    let p = dummy
    let p1 = list1,
        p2 = list2
    while (p1 && p2) {
        if (p1.val < p2.val) {
            p.next = p1
            p1 = p1.next
        } else {
            p.next = p2
            p2 = p2.next
        }
        p = p.next
    }
    if (p1) p.next = p1
    if (p2) p.next = p2
    return dummy.next
}
```

#### lc.23 åˆå¹¶ K ä¸ªæœ‰åºé“¾è¡¨ hard

è¿™é“é¢˜æ¯”è¾ƒæœ´ç´ çš„åšæ³•æ˜¯ï¼šå·²çŸ¥ä¸¤ä¸ªæœ‰åºé“¾è¡¨çš„åˆå¹¶ï¼Œé‚£ä¹ˆéå†æ‰€æœ‰é“¾è¡¨é€æ¡åˆå¹¶å³å¯ã€‚

æ€§èƒ½å¼ºä¸€ç‚¹çš„åšæ³•æ˜¯åˆ©ç”¨ä¼˜å…ˆé˜Ÿåˆ—ã€‚JS ä¸­æ²¡æœ‰ï¼Œå¾—å…ˆæ‰‹åŠ¨å®ç°ï¼›Java ä¸­æœ‰ PQï¼Œå¾—è®¾ç½®æ¯”è¾ƒå‡½æ•°ã€‚

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode[]} lists
 * @return {ListNode}
 */
var mergeKLists = function (lists) {
    let dummy = new ListNode(-1)
    let p = dummy
    lists = lists.filter(item => item !== null)
    const pq = new PQ(lists, (a, b) => a > b)
    while (!pq.isEmpty()) {
        const top = pq.pop()
        p.next = top
        p = p.next

        if (top && top.next) {
            pq.push(top.next)
        }
    }
    return dummy.next
}

/** æ‰‹åŠ¨å®ç°ä¼˜å…ˆé˜Ÿåˆ— */
class PQ {
    constructor(data, comparator) {
        this.data = data
        this.comparator = comparator
        for (let i = data.length >> 1; i >= 0; --i) this.down(i)
    }
    up(i) {
        while (i > 0 && this.comparator(this.data[(i - 1) >> 1].val, this.data[i].val)) {
            this.swap((i - 1) >> 1, i)
            i = (i - 1) >> 1
        }
    }
    down(i) {
        let left = 2 * i + 1
        while (left < this.data.length) {
            let min = left
            if (left + 1 < this.data.length) {
                min = this.comparator(this.data[left + 1].val, this.data[left].val)
                    ? left
                    : left + 1
            }
            min = this.comparator(this.data[min].val, this.data[i].val) ? i : min
            if (min === i) break
            this.swap(min, i)
            i = min
            left = 2 * i + 1
        }
    }
    push(val) {
        this.up(this.data.push(val) - 1)
    }
    pop() {
        this.swap(0, this.data.length - 1)
        const top = this.data.pop()
        this.down(0)
        return top
    }
    swap(i, j) {
        const temp = this.data[i]
        this.data[i] = this.data[j]
        this.data[j] = temp
    }
    isEmpty() {
        return this.data.length === 0
    }
}
```

å¦ä¸€ç§é€’å½’è§£ï¼šå½’å¹¶

```js
var mergeKLists = function (lists) {
    if (lists.length === 0) return null
    if (lists.length === 1) return lists[0]
    const mid = lists.length >> 1
    const left = mergeKLists(lists.slice(0, mid))
    const right = mergeKLists(lists.slice(mid))
    return mergeTwoList(left, right)
}
function mergeTwoList(a, b) {
    if (!a) return b
    if (!b) return a
    if (a.val < b.val) {
        a.next = mergeTwoList(a.next, b)
        return a
    } else {
        b.next = mergeTwoList(a, b.next)
        return b
    }
}
```

#### lc.24 ä¸¤ä¸¤äº¤æ¢é“¾è¡¨ä¸­çš„èŠ‚ç‚¹

ä¸é”™çš„ä¸€é“é¢˜

```js
var swapPairs = function (head) {
    if (head === null || head.next === null) return head
    const newHead = head.next // cache
    head.next = swapPairs(head.next.next)
    newHead.next = head // å½’ - ååºä½ç½®
    return newHead
}

/** è¿­ä»£è§£æ³• */
var swapPairs = function (head) {
    const dummy = new ListNode(-1)
    dummy.next = head
    let p = dummy
    while (p.next !== null && p.next.next !== null) {
        const a = p.next // cache
        const b = p.next.next // cache

        p.next = b
        a.next = b.next
        b.next = a
        p = a
    }
    return dummy.next
}
```

å¯ä»¥çœ‹è§ï¼Œæ— è®ºæ˜¯é€’å½’è¿˜æ˜¯è¿­ä»£ï¼Œå› ä¸ºè¦å˜åŠ¨åæ–¹çš„èŠ‚ç‚¹ï¼Œæ‰€ä»¥ä¸€èˆ¬éƒ½å¯ä»¥å…ˆåšä¸€å±‚ç¼“å­˜ã€‚

#### lc.83 åˆ é™¤é“¾è¡¨çš„é‡å¤å…ƒç´  easy

```js
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var deleteDuplicates = function (head) {
    if (!head) return head
    let p = head
    while (p.next) {
        if (p.val === p.next.val) {
            p.next = p.next.next
        } else {
            p = p.next
        }
    }
    return head
}
```

#### å•é“¾è¡¨åˆ†åŒºï¼ˆå·¦<,ä¸­=,å³>ï¼‰

åœ¨ä¸‰è·¯å¿«æ’ä¸­ï¼Œæœ‰ç±»ä¼¼çš„æ“ä½œã€‚æ‰€ä»¥å¦‚æœå€ŸåŠ©æ•°ç»„ï¼Œé‚£ä¹ˆå°±æ˜¯è·å…°å›½æ——é—®é¢˜äº†ã€‚

ä½†æ˜¯è¿™æ ·åšæ—¶é—´å¤æ‚åº¦å°±é«˜äº†ï¼Œå¯¹äºé“¾è¡¨ï¼Œèƒ½ç”¨æŒ‡é’ˆæ“ä½œçš„ï¼Œå°±ä¸å€ŸåŠ©é¢å¤–ç©ºé—´ã€‚è¦æƒ³ç©ºé—´å¤æ‚åº¦ä¸º O(1)ï¼Œé‚£ä¹ˆå°±å¾—å€ŸåŠ© 6 ä¸ªå˜é‡ <head <tailï¼Œ =head =tailï¼Œ >head >tailã€‚

##### lc.86 åˆ†éš”é“¾è¡¨

è¿™é“é¢˜æ˜¯ä¸Šæ–¹åˆ†åŒºçš„ç®€åŒ–ç‰ˆæœ¬ï¼Œåªç”¨æŠŠå°äº X çš„èŠ‚ç‚¹æ”¾åˆ°å¤§äºç­‰äº X çš„èŠ‚ç‚¹ä¹‹å‰å³å¯ã€‚

```js
/**
 * @param {ListNode} head
 * @param {number} x
 * @return {ListNode}
 */
var partition = function (head, x) {
    if (head === null || head.next === null) return head
    let small = new ListNode(-1)
    let large = new ListNode(-1)
    let p = head,
        p1 = small,
        p2 = large
    while (p !== null) {
        const val = p.val
        if (val < x) {
            p1.next = p
            p1 = p1.next
        } else {
            p2.next = p
            p2 = p2.next
        }

        p = p.next
    }
    p2.next = null // æ³¨æ„éœ€è¦ç»™å¤§çš„æ”¶å°¾~
    p1.next = large.next
    return small.next
}
```

#### lc.138 å¤åˆ¶å«æœ‰éšæœºæŒ‡é’ˆçš„é“¾è¡¨

```java
/**
 * Javaç‰ˆæœ¬ï¼šè¿™é“é¢˜è¦æ˜¯ç©ºé—´å¤æ‚åº¦ä¸éœ€è¦ O(1)ï¼Œé‚£ä¹ˆç”¨å“ˆå¸Œè¡¨å°±æŒºå¥½åšçš„
 *
 * O(1) çš„ç©ºé—´å¤æ‚åº¦ï¼Œå°±éœ€è¦ä¸€å®šçš„æŠ€å·§äº†ï¼Œå°±æ˜¯ æ‹¼æ¥+æ‹†åˆ†ã€‚
 */
 // å“ˆå¸Œè¡¨
class Solution {
  public Node copyRandomList(Node head) {
      Map<Node, Node> map = new HashMap<>();
      Node p = head;
      while (p != null) {
          map.put(p, new Node(p.val));
          p = p.next;
      }
      p = head;
      while(p != null) {
          map.get(p).next = map.get(p.next);
          map.get(p).random = map.get(p.random);
          p = p.next;
      }
      return map.get(head);
  }
}
/** ç©ºé—´å¤æ‚åº¦ O(1) */
public Node copyRandomList(Node head) {
  // æ°åˆ°å¥½å¤„çš„æ‹¼æ¥ï¼Œå¤åˆ¶èŠ‚ç‚¹ç›´æ¥æ‹¼åˆ°åŸèŠ‚ç‚¹åï¼Œè¿™æ ·ä¼šå‘ç°ï¼š
  // ** æ–°èŠ‚ç‚¹çš„randomæŒ‡å‘çš„å°±æ˜¯åŸèŠ‚ç‚¹randomæŒ‡å‘èŠ‚ç‚¹çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ **
  // 1.å¤åˆ¶èŠ‚ç‚¹
  Node p = head;
  while (p != null) {
      Node newNode = new Node(p.val);
      newNode.next = p.next;
      p.next = newNode;
      p = newNode.next;
  }
  // 2.è®¾ç½® random
  p = head;
  while (p != null) {
      if(p.random != null) {
          p.next.random = p.random.next;
      }
      p = p.next.next;
  }
  // 3. åˆ†ç¦»é“¾è¡¨
  Node dummy = new Node(-1);
  p = head;
  Node curr = dummy;
  while (p != null) {
      curr.next = p.next;
      curr = curr.next;
      p.next = curr.next;
      p = p.next;
  }
  return dummy.next;
}
```

```js
/**
 * // Definition for a Node.
 * function Node(val, next, random) {
 *    this.val = val;
 *    this.next = next;
 *    this.random = random;
 * };
 */

/**
 * @param {Node} head
 * @return {Node}
 */
var copyRandomList = function (head) {
    /** å°½å¯èƒ½é™ä½ç©ºé—´å¤æ‚åº¦ï¼Œä½¿ç”¨æ‹¼æ¥æŠ€å·§ */
    let p = head
    while (p !== null) {
        const cpNode = new Node(p.val)
        cpNode.next = p.next
        p.next = cpNode
        p = cpNode.next
    }
    p = head
    while (p !== null) {
        if (p.random) {
            p.next.random = p.random.next
        }
        p = p.next.next
    }
    const dummy = new Node(-1)
    let curr = dummy
    p = head
    while (p !== null) {
        curr.next = p.next
        curr = curr.next
        p.next = curr.next
        p = p.next
    }
    return dummy.next
}
```

#### å•é“¾è¡¨ç¯ç›¸å…³é—®é¢˜

å¿«æ…¢æŒ‡é’ˆåˆ¤æ–­æ˜¯å¦æœ‰ç¯çš„åŸç†æ˜¯ï¼šå¦‚æœæœ‰ç¯ï¼Œåˆ™å¿…å®šä¸¤ä¸ªæŒ‡é’ˆä¼šç›¸é‡ï¼›å¦åˆ™ï¼Œå¿«æŒ‡é’ˆå°†èµ°åˆ°ç©ºã€‚

##### lc.141 åˆ¤æ–­é“¾è¡¨æ˜¯å¦æœ‰ç¯ easy

```js
/**
 * @param {ListNode} head
 * @return {boolean}
 */
var hasCycle = function (head) {
    if (head == null) return false
    let s = head,
        f = head.next
    while (s !== f) {
        if (f == null || f.next == null) return false
        s = s.next
        f = f.next.next
    }
    return true
}
```

##### lc.142 è¿”å›ç¯çš„èµ·ç‚¹

æ­¤é¢˜åº”ç”¨çš„æ˜¯è‘—åçš„ [Floyd åˆ¤åœˆç®—æ³•ï¼ˆç»´åŸºç™¾ç§‘ï¼‰](https://zh.wikipedia.org/wiki/Floyd%E5%88%A4%E5%9C%88%E7%AE%97%E6%B3%95)ã€‚åº”ç”¨å¿«æ…¢æŒ‡é’ˆï¼Œç¬¬ä¸€æ¬¡ç›¸é‡åå¿«æŒ‡é’ˆå›åˆ°å¤´éƒ¨å’Œæ…¢æŒ‡é’ˆä¸€èµ·èµ°ï¼Œå†æ¬¡ç›¸é‡å°±æ˜¯ç¯çš„èµ·ç‚¹ã€‚

å‡è®¾ head åˆ°ç¯èµ·ç‚¹çš„è·ç¦»ä¸º aï¼Œç¯èµ·ç‚¹åˆ°å¿«æ…¢æŒ‡é’ˆç›¸é‡çš„è·ç¦»ä¸º bï¼Œç¯é•¿åº¦ä¸º c ï¼Œåˆ™ï¼š

-   æ…¢æŒ‡é’ˆèµ°äº† a + bï¼Œ
-   å¿«æŒ‡é’ˆèµ°äº† a + b + n\*cï¼Œ n ä¸ºåœˆæ•°

ç¬¬ä¸€æ¬¡ç›¸é‡æ—¶ï¼Œæ…¢æŒ‡é’ˆèµ° kï¼Œå¿«æŒ‡é’ˆèµ° 2kï¼Œå¿«æ¯”æ…¢å¤šèµ°äº† k æ­¥ï¼Œæ‰€ä»¥ n \* c = kï¼Œå› æ­¤ k æ˜¯ç¯çš„æ•´æ•°å€ã€‚æ‰€ä»¥å›åˆ°èµ·ç‚¹çš„æŒ‡é’ˆè¦å†èµ° k - b æ­¥æ‰åˆ°èµ·ç‚¹ï¼Œè€Œä»ç¬¬ä¸€æ¬¡ç›¸é‡ç‚¹èµ°åˆ°ç¯èµ·ç‚¹çš„è·ç¦»ä¹Ÿæ°å¥½ä¹Ÿä¸º k - bã€‚

```js
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var detectCycle = function (head) {
    if (head === null || head.next === null) return null
    let s = head,
        f = head
    while (true) {
        if (f == null || f.next == null) return null
        s = s.next
        f = f.next.next
        if (s === f) break
    }

    f = head
    while (s !== f) {
        f = f.next
        s = s.next
    }
    return s
}
```

#### å•é“¾è¡¨ç›¸äº¤é—®é¢˜

> å¤„ç†é“¾è¡¨ç›¸äº¤ä¸€ç±»çš„é—®é¢˜ï¼Œæ ¸å¿ƒåœ¨äº **ã€ŒæŠ¹é™¤é•¿åº¦å·®å¼‚ã€**ï¼Œç„¶åé½å¤´å¹¶è¿›ï¼Œæœ‰ç›¸ç­‰èŠ‚ç‚¹åˆ™ç›¸äº¤ã€‚

##### lc.160 ç›¸äº¤é“¾è¡¨ easy

```js
/**
 * @param {ListNode} headA
 * @param {ListNode} headB
 * @return {ListNode}
 */
var getIntersectionNode = function (headA, headB) {
    if (headA == null || headB == null) return null

    let n = 0
    let p1 = headA,
        p2 = headB // å‡å®š p1 ä¸ºé•¿ï¼Œp2 ä¸º çŸ­
    while (p1 !== null) {
        n++
        p1 = p1.next
    }
    while (p2 !== null) {
        n--
        p2 = p2.next
    }

    if (n > 0) {
        p1 = headA
        p2 = headB
    } else {
        p1 = headB
        p2 = headA
    }

    n = Math.abs(n)
    while (n--) {
        p1 = p1.next
    }

    while (p1 !== p2) {
        p1 = p1.next
        p2 = p2.next
    }

    return p1
}
```

```java
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        if (headA == null || headB == null) return null;
        ListNode l = headA, s = headB;
        int n = 0;
        while (l != null) {
            n++;
            l = l.next;
        }
        while (s != null) {
            n--;
            s = s.next;
        }
        if (l != s) return null;
        l = n > 0 ? headA : headB;
        s = n > 0 ? headB : headA;
        n = Math.abs(n);
        while (n != 0) {
            l = l.next;
            n--;
        }
        while (l != s) {
            l = l.next;
            s = s.next;
        }
        return l;
    }
}
```

æœ‰ä¸ªå–å·§çš„å°æŠ€å·§æ˜¯ï¼Œå½“ä¸¤ä¸ªæŒ‡é’ˆç¬¬ä¸€æ¬¡èµ°åˆ°æœ«å°¾åï¼Œåˆ†åˆ«è·³åˆ°å¯¹æ–¹é“¾è¡¨ä¸Šå»ï¼Œè¿™æ ·*ç­‰ä»·äº*æŠ¹é™¤äº†é•¿åº¦å·®å¼‚ï¼Œå¦‚æœ‰ç›¸äº¤ï¼Œåˆ™ä¼šèµ°åˆ°ç›¸åŒèŠ‚ç‚¹ä¸Šã€‚å…·ä½“è§å®˜è§£ã€‚

##### è¿›é˜¶ï¼šæœ‰ç¯å•é“¾è¡¨ç›¸äº¤

```java
/**
 * æœ‰ç¯å•é“¾è¡¨ç›¸äº¤è¦åˆ†æ¸…æ¥šæƒ…å†µï¼š
 * 1. ä¸ç›¸äº¤
 * 2. ç¯çš„èµ·å§‹èŠ‚ç‚¹ä¸€æ ·ï¼Œåˆ™æŠŠè¿™ä¸ªèµ·å§‹èŠ‚ç‚¹çœ‹æˆä¸¤ä¸ªæ— ç¯é“¾è¡¨çš„ç»ˆç‚¹ï¼Œåˆ©ç”¨ä¸Šé¢˜çš„è§£æ³•æ±‚å‡ºç›¸äº¤èŠ‚ç‚¹å³å¯
 * 3. ç¯çš„èµ·å§‹èŠ‚ç‚¹ä¸ä¸€æ ·ï¼Œåˆ™è¿™ä¸¤ä¸ªèŠ‚ç‚¹éƒ½æ˜¯ç›¸äº¤èŠ‚ç‚¹ï¼Œè¿”å›ä»»æ„ä¸€ä¸ªå³å¯
 *
 * 1 å’Œ 3 æƒ…å†µçš„åŒºåˆ†æ˜¯ï¼Œä¸€ä¸ªç¯çš„èŠ‚ç‚¹ç»§ç»­èµ°ï¼Œèµ°å›è‡ªå·±ä¹‹å‰èƒ½é‡åˆ°å¦ä¸€ä¸ªç¯çš„èŠ‚ç‚¹å°±æ˜¯æƒ…å†µ3ï¼Œå¦åˆ™å°±æ˜¯æƒ…å†µ1
 */
public ListNode bothLoop(ListNode head1, ListNode head2, ListNode loop1, ListNode loop2) {
    /**
     * ç¬¬ 2 ç§æƒ…å†µï¼Œä¸¤ä¸ªæœ‰ç¯é“¾è¡¨å…±ç”¨ç¯èµ·ç‚¹ï¼Œ
     * é‚£ä¹ˆæ­¤æ—¶å¯ä»¥æŠŠç¯çš„èµ·ç‚¹çœ‹æˆæ˜¯head1å’Œhead2åˆ°çš„æ— ç¯é“¾è¡¨çš„ç»ˆç‚¹ï¼Œ
     * ä¹Ÿå°±è½¬åŒ–æˆäº†å¯»æ‰¾ä¸¤ä¸ªæ— ç¯å•é“¾è¡¨ç›¸äº¤ç‚¹çš„é—®é¢˜äº†ã€‚
     */
    if (loop1 == loop2) {
        ListNode p1 = head1, p2 = head2;
        int n = 0;
        while (p1 != loop1) {
            n++;
            p1 = p1.next;
        }
        while (p2 != loop2) {
            n--;
            p2 = p2.next;
        }
        p1 = n > 0 ? head1 : head2;
        p2 = n > 0 ? head2 : head1;
        n = Math.abs(n);
        while (n > 0) {
            p1 = p1.next;
            n--;
        }
        while (p1 != p2) {
            p1 = p1.next;
            p2 = p2.next;
        }
        return p1;
    } else {
        /**
         * ç¬¬ 1 ç§æƒ…å†µä¸ç›¸äº¤å’Œç¬¬ 3 ç§æƒ…å†µç›¸äº¤åœ¨ç¯ä¸Šä¸åŒçš„èŠ‚ç‚¹
         * åŒºåˆ†æ–¹å¼æ˜¯è®©èŠ‚ç‚¹ä» loop1 å¼€å§‹ç»§ç»­ç»•ç¯èµ°ï¼Œèƒ½é‡åˆ° loop2 åˆ™è¯´æ˜ç›¸äº¤äº†ï¼Œå¦åˆ™ä¸ºä¸ç›¸äº¤
         */
        ListNode p = loop1.next; // å…ˆå‰è¿›ä¸€æ­¥ï¼Œå¦åˆ™whileè¿›ä¸å»å–½ï½
        while (p != loop1) {
            if (p == loop2) {
                return loop2; // loop1 loop2éƒ½æ˜¯ç›¸äº¤ç‚¹ï¼Œéšæ„è¿”å›ä¸€ä¸ª
            }
            p = p.next;
        }
        return null;
    }
}
```

#### åè½¬é“¾è¡¨é—®é¢˜

##### lc.206 åè½¬é“¾è¡¨ hot easy

æœ€åŸºæœ¬çš„è€ƒéªŒå¯¹åŒæŒ‡é’ˆå’Œé€’å½’çš„ç†è§£ã€‚ä¸é”™çš„ä¸€é“ç»å…¸é¢˜ã€‚

```java
// è¿­ä»£æ³•ï¼Œé‚£å°±æ˜¯åŒæŒ‡é’ˆäº†ï¼Œå…ˆå­˜å‚¨åç»§èŠ‚ç‚¹ï¼Œå‰©ä¸‹çš„éƒ½å¥½åŠ
public ListNode reverseList(ListNode head) {
    ListNode p = head, pre = null;
    while(p != null) {
        ListNode next = p.next; // å‚¨å­˜åç»§èŠ‚ç‚¹
        p.next = pre;
        pre = p;
        p = next;
    }
    return  pre;
}
// é€’å½’æ³•
public ListNode reverseList(ListNode head) {
  if (head == null || head.next == null) return head;
  ListNode newHead = reverseList(head.next); // newHead æ˜¯æœ€åä¸€ä¸ªèŠ‚ç‚¹
  // ååºéå†ï¼Œå‡è®¾é€’å½’åˆ°æœ€åäº†ï¼Œæ­¤æ—¶çš„ head æ˜¯æœ€åä¸€ä¸ªèŠ‚ç‚¹çš„å‰ä¸€ä¸ªèŠ‚ç‚¹
  head.next.next = head; // æŠŠä¸‹ä¸€ä¸ªèŠ‚ç‚¹çš„nextæŒ‡å‘è‡ªèº«
  head.next = null; // æŠŠè‡ªèº«çš„nextæŒ‡å‘null
  return newHead; // è¿”å›å°¾éƒ¨èŠ‚ç‚¹çš„å¼•ç”¨æŒ‡é’ˆå³å¯
}
```

```js
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var reverseList = function (head) {
    if (!head || !head.next) return head
    const newHead = reverseList(head.next)
    head.next.next = head
    head.next = null
    return newHead
}

var reverseList = function (head) {
    let p = head,
        pre = null
    while (p) {
        const next = p.next
        p.next = pre
        pre = p
        p = next
    }
    return pre
}
```

##### lc.92 åè½¬é“¾è¡¨ II

å¦‚è¿‡ä¸è¦æ±‚åªä¸€æ¬¡éå†ï¼Œåˆ©ç”¨ lc.206 å°±å¯ä»¥å®Œæˆäº†ã€‚

åªèƒ½éå†ä¸€æ¬¡çš„è¯ï¼Œéœ€è¦æŠ€å·§ï¼Œå°±æ˜¯æ¯éå†åˆ°åè½¬åŒºé—´å†…çš„ä¸€ä¸ªå…ƒç´ ï¼Œå°±æŠŠè¿™ä¸ªå…ƒç´ æ”¾åˆ°åè½¬åŒºé—´çš„å¤´éƒ¨ã€‚

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @param {number} left
 * @param {number} right
 * @return {ListNode}
 */
var reverseBetween = function (head, left, right) {
    const dummy = new ListNode(-1) // left å¯èƒ½ä¸ºå¤´ï¼Œå®ˆå«ç®€åŒ–æ“ä½œ
    dummy.next = head

    let p = dummy
    for (let i = 0; i < left - 1; ++i) {
        p = p.next
    }

    const len = right - left + 1
    let curr = p.next // ç›´æ¥ä»åŒºé—´ç¬¬äºŒä¸ªèŠ‚ç‚¹å¼€å§‹åè½¬
    let step = len - 1
    while (step--) {
        const next = curr.next
        curr.next = next.next
        next.next = p.next
        p.next = next
    }

    return dummy.next
}
```

##### lc.25 K ä¸ªä¸€ç»„åè½¬é“¾è¡¨ hard

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @param {number} k
 * @return {ListNode}
 */
var reverseKGroup = function (head, k) {
    if (head === null) return head
    let a = (b = head)
    for (let i = 0; i < k; ++i) {
        if (b == null) return head // ä¸è¶³ k
        b = b.next
    }

    const newHead = reverse(a, b)
    a.next = reverseKGroup(b, k) // [a, b) åè½¬å a çš„ next ä¸ºå‰©ä¸‹çš„é“¾è¡¨åè½¬
    return newHead
}

/**
 * åè½¬ [head, tail) åŒºé—´çš„é“¾è¡¨ï¼Œå…¶å®æ™®é€šçš„åè½¬é“¾è¡¨åè½¬çš„å°±æ˜¯ [head, null) åŒºé—´ç½¢äº†
 */
function reverse(head, tail) {
    let prev = null,
        curr = head
    while (curr !== tail) {
        const next = curr.next
        curr.next = prev
        prev = curr
        curr = next
    }
    return prev
}
```

#### lc.234 å›æ–‡é“¾è¡¨ easy

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @return {boolean}
 */
var isPalindrome = function (head) {
    if (head === null) return false
    let s = head,
        f = head
    while (f !== null && f.next !== null) {
        s = s.next
        f = f.next.next
    }

    // å¯¹ååŠéƒ¨åˆ†ï¼Œ s è¿›è¡Œåè½¬
    let prev = null
    while (s !== null) {
        const next = s.next
        s.next = prev
        prev = s
        s = next
    }

    // å¯¹ prev å’Œ head è¿›è¡Œæ¯”è¾ƒ
    while (prev) {
        if (prev.val !== head.val) return false
        prev = prev.next
        head = head.next
    }

    return true
}
```

---

<!-- ## æ’å…¥ä¸€ä¸‹Javaå“ˆå¸Œè¡¨çš„äº†è§£

åœ¨ javascript ä¸­çš„ Set å’Œ Map å’±å°±ä¸è¯´å•¥äº†ï¼Œéæ­£è§„å†› ğŸ˜„ã€‚æ¥çœ‹çœ‹ java çš„ï¼š

1. æ— åºè¡¨
    - HashSet: add remove containsï¼Œå¯¹å‘€ c++ ä¸­çš„ unordered_set
    - HashMap: put remove containsKeyï¼Œå¯¹åº” c++ ä¸­çš„ unordered_map
2. æœ‰åºè¡¨
    - TreeSetï¼šå®ƒæ˜¯æŒ‰å‡åºå¯¹å…ƒç´ è¿›è¡Œæ’åºï¼Œå¯¹åº” c++ ä¸­çš„ ordered_set
    - TreeMapï¼šåŸºäºçº¢é»‘æ ‘çš„ NavigableMap å®ç°ï¼Œå®ƒæ ¹æ®å…¶é”®çš„è‡ªç„¶é¡ºåºæ’åºï¼Œå¯¹åº” c++ ä¸­çš„ ordered_map

è®°å¾—ä¹‹å‰å­¦ java çš„æ—¶å€™ï¼Œ HashSet åº•å±‚å°±æ˜¯ HashMapï¼Œåªä¸è¿‡æ²¡æœ‰ value åªæœ‰ key ç½¢äº†ï¼Œè€Œå¸¸è§„çš„ HashMap çš„åº•å±‚åˆ™æ˜¯ é“¾è¡¨ï¼Œåœ¨ java ä¸­ï¼Œå½“é“¾è¡¨çš„é•¿åº¦åˆ°è¾¾ 8 æ—¶ï¼Œå°±ä¼šè‡ªåŠ¨æ‰©å®¹ï¼Œé“¾è¡¨ä¹Ÿä¼šé‡æ–°åˆ†é…ï¼Œå¥½åƒæœ‰çº¢é»‘æ ‘ä»€ä¹ˆçš„ï¼ˆä¸æ¸…æ¥šï¼Œååºå­¦ä¹ å†å›å¤´è¡¥å……ï¼‰ï¼Œåé¢äº†è§£åˆ°å“ˆå¸Œå‡½æ•°çš„æ—¶å€™ï¼Œå°±æ›´åŠ æ¸…æ¥šäº†ï¼Œç¦»æ•£å‡½æ•°ä½¿å¾—åˆ†é…ç©ºé—´æ—¶åŸºæœ¬æ˜¯ç¦»æ•£å‡åŒ€çš„ã€‚

1. æ”¾å…¥æ— /æœ‰åºè¡¨çš„ä¸œè¥¿ï¼Œå¦‚æœæ˜¯åŸºç¡€ç±»å‹ï¼Œå†…éƒ¨æŒ‰å€¼ä¼ é€’ï¼Œå†…å­˜å ç”¨å°±æ˜¯è¿™ä¸ªä¸œè¥¿çš„å¤§å°
2. æ”¾å…¥æ— åºè¡¨çš„ä¸œè¥¿ï¼Œå¦‚æœä¸æ˜¯åŸºç¡€ç±»å‹ï¼Œå†…éƒ¨æŒ‰å¼•ç”¨ä¼ é€’ï¼Œå†…å­˜å ç”¨çš„å°±æ˜¯è¿™ä¸ªä¸œè¥¿çš„å†…å­˜åœ°å€çš„å¤§å°ï¼Œjava ä¸­æ˜¯ 8 ä¸ªå­—èŠ‚
3. æ”¾å…¥æœ‰åºè¡¨çš„ä¸œè¥¿ï¼Œå¦‚æœä¸æ˜¯åŸºç¡€ç±»å‹ï¼Œ**å¿…é¡»æä¾›æ¯”è¾ƒå™¨**ï¼Œå†…éƒ¨æŒ‰å¼•ç”¨ä¼ é€’...ã€‚

> é‡ç‚¹ï¼šæ— åºè¡¨ çš„å¢åˆ æ”¹æŸ¥çš„æ—¶é—´å¤æ‚åº¦éƒ½æ˜¯ **å¸¸æ•°** çº§åˆ«ï¼ˆæ¯”è¾ƒå¤§çš„å¸¸æ•° å“ˆå“ˆï¼‰ï¼Œæœ‰åºè¡¨çš„æ—¶é—´å¤æ‚åº¦éƒ½æ˜¯ O(logn) çº§åˆ«

--- -->
