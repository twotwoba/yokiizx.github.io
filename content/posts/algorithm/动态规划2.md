---
title: '动态规划2'
date: 2022-10-15T23:06:39+08:00
tags: [algorithm, dynamic programming]
---

经典背包问题来一沓~  
背包问题的经典资料当然是：背包九讲。此文只记录下 0-1 背包和完全背包。剩下的有时间可以再学习学习。

借用一下代码随想录的图：

![](https://cdn.staticaly.com/gh/yokiizx/picgo@master/img/202210161922324.png)

---

01 背包一定要吃透，其实就是怎么做出最佳选择的原理，所以一般都是通过动态规划来处理的，往往会在脑海中给出这么个二维矩阵来填格子。

题目：
有 n 件物品和一个最多能背重量为 w 的背包。第 i 件物品的重量是 weight[i]，得到的价值是 value[i] 。每件物品只能用一次，求解将哪些物品装入背包里物品价值总和最大。

分析：

1.  定义 `dp[i][j]`: 表示前 i (索引对应为`[0..i-1]`) 个物品中，当前背包容量为 `j`，可以装入价值的最大值
2.  递归公式，对于物品有选择和不选两种情况，取较大者即可
    - 不选择物品 i，则 `dp[i][j] = dp[i-1][j]`
    - 选择物品 i，则 `dp[i][j] = dp[i-1][j-weight[i - 1]] + values[i-1]` (重要,是因为 前 i 个 索引为 i - 1)
3.  base case
    - 当 j 为 0，即背包容量为 0，`dp[i][0] = 0`
    - 当 i 为 0，即物品个数为 0，`dp[0][j] = 0`

```JavaScript
/**
 * @desc    0-1 背包问题
 * @param   {Number[]} weight - 物品重量集合
 * @param   {Number[]} value  - 物品价值集合
 * @param   {Number}   size   - 背包容量大小
 * @return  {Number}   max    - 能装价值最大值
 */
function zeroOne(weight, value, size) {
  const m = weight.length // m个物品
  // 1. dp[i][j] 表示前 i 个物品,背包容量为j时,价值最大为dp[i][j] (求dp[m][size])
  const dp = Array.from(new Array(m + 1), _ => new Array(size + 1).fill(0))
  // base case 初始化时已做 dp[0][..] = 0; dp[..][0] = 1
  for(let i = 1; i <= m; ++i) {
    for(let j = 1; j <= size; ++j) {
      // 只能不装入背包
      if(weight[i-1] > j) dp[i][j] = dp[i-1][j]
      else dp[i][j] = Math.max(dp[i-1][j],dp[i-1][j-weight[i-1]] + value[i-1])
    }
  }
  return dp[m][size]
 }

// test
const weight = [12, 2, 1, 1]
const value = [4, 2, 1, 2]
const size = 15
console.log(zeroOne(weight, value, size)) // 8
```

---

##### [416.分割等和子集](https://leetcode.cn/problems/partition-equal-subset-sum/)

这种分割类的，大部分都可以使用回溯去做，但是性能堪忧，这个时候就应该考虑一下动态规划了。

其实这道题就是 01 背包问题，只不过没明说而已：对数组求和得 sum，是否存在子集和为 sum / 2？这不就是背包容量为 sum/2，从数组中选择元素且每个元素都只能使用一次来填充背包喽。

```JavaScript
/**
 * @param {number[]} nums
 * @return {boolean}
 */
var canPartition = function(nums) {
    // 定义dp[i][j]: 表示前i个元素可以装满大小为j时的背包, (j是变化的 j为0时装满)
    // 不放入第i个(nums[i-1]), dp[i][j] = dp[i-1][j] 放入第i个, dp[i][j] = dp[i-1][j-nums[i-1]]
    // base case: dp[..][0] = true;  dp[0][..] = 0
    // 这个有必要解释一下: 背包没有空间的时候，就相当于装满了，而当没有物品可选择的时候，肯定没办法装满背包。
    const sum = nums.reduce((t,v) => t + v, 0)
    console.log(sum)
    if(sum % 2 !== 0) return false
    const m = nums.length
    const target = sum / 2
    const dp = Array.from(new Array(m + 1), _ => new Array(target + 1).fill(false))
    for(let i = 0; i <= m; ++i) dp[i][0] = true
    for(let i = 1; i <= m; ++i) {
        for(let j = 1; j <= target; ++j) {
            if(nums[i - 1] > j) dp[i][j] = dp[i-1][j] // 只能不装
            else dp[i][j] = dp[i-1][j] || dp[i-1][j-nums[i-1]] // 可装可不装
        }
    }
    return dp[m][target]
};
```

##### [1049.最后一块石头的重量 II](https://leetcode.cn/problems/last-stone-weight-ii/)

不得不说，没有一定经验的人很难想得到这道题也能转为 01 背包问题 🙄。  
其实就是：尽量分为两堆石头，这两个堆重量尽量靠近，也就是说让其中一个堆尽量靠近 `总重 / 2`。

```JavaScript
/**
 * @param {number[]} stones
 * @return {number}
 */
var lastStoneWeightII = function(stones) {
    // 定义 dp[i][j]: 表示 前i个石头重量和最接近 sum/2 的重量是 dp[i][j], 结果为sum-2*dp[m][sum/2]
    // 递推公式:不放入或放入取最大, 放入需要足够的空间:
    // Math.max(dp[i-1][j], dp[i-1][j-stones[i-1]] + stones[i-1])
    // base case dp[0][..] = 0 dp[..][0] = 0
    const sum = stones.reduce((t,v) => t + v, 0)
    const target = sum >> 1
    const m = stones.length
    const dp = Array.from(new Array(m + 1), _ => new Array(target + 1).fill(0))
    for(let i = 1; i <= m; ++i) {
        for(let j = 1; j <= target; ++j) {
            if(stones[i -1] > j) dp[i][j] = dp[i-1][j] // 不能放入
            else dp[i][j] = Math.max(dp[i-1][j], dp[i-1][j-stones[i-1]] + stones[i-1])
        }
    }
    return sum - 2 * dp[m][target]
};
```

## 状态压缩

这个是优化方案，可以降低空间复杂度，推荐看看 labuladong 大佬的文章。（因为他的网站经常变换，就不贴链接了）。

**对于状态压缩要有一副二维 table 的脑图，以及对遍历方向掌握到位。**

```JavaScript
for (int i = n - 2; i >= 0; i--) {
    for (int j = i + 1; j < n; j++) {
        // 状态转移方程
        if (s[i] == s[j])
            dp[i][j] = dp[i + 1][j - 1] + 2;
        else
            dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);
    }
}
```

对于上方递推公式，`dp[i][j]` 只依赖于 `dp[i+1][j-1]`,`dp[i+1][j]`,`dp[i][j-1]`，见下图。

![](https://cdn.staticaly.com/gh/yokiizx/picgo@master/img/202210180953079.png)

记住：**空间压缩的核心思路就是，将二维数组「投影」到一维数组**：

![](https://cdn.staticaly.com/gh/yokiizx/picgo@master/img/202210181835977.png)

> 在代码中呢，就是无脑去掉 dp[i][j] 的 [i] 这个维度，去掉维度后，可能会产生覆盖问题。  
> 然后思考每个一维 dp 的含义。  
> 有可能需要调整遍历顺序。  
> base case 也要看着修改，同样也是投影

继续上面的例子：

i 从下往上遍历, j 从左往右遍历，即 i 是控制遍历层数的，i+1 就是上一层。

- dp[j]: 在被赋值之前代表上一轮遍历的值，即 dp[i+1][j]
- dp[j-1]: 因为 j 之前的已经被覆盖过了，所以代表 dp[i][j-1]
- 现在就差一个 dp[i+1][j-1] 了，因为一维，它被 dp[i][j-1] 无情地覆盖掉了，可是按照原来的二维 dp 必须得知道这个值才行，咋办呢？其实可以很自然的想到，用个变量缓存住不就好了？Yes，you got it!

```JavaScript
for (int i = n - 2; i >= 0; i--) {
    // 每层循环都定义一个变量协助储存一维数组要求 j 时 j-1 位置被覆盖前的值
    let pre = 0;
    for (let j = i + 1; j < n; j++) {
        let temp = dp[j]; // dp[j] 此时取到的是上一轮遍历的值 即 dp[i+1][j]
        if (s[i] == s[j])
            // dp[i][j] = dp[i+1][j-1] + 2;
            dp[j] = pre + 2;
        else
            // dp[i][j] = max(dp[i+1][j], dp[i][j-1]);
            dp[j] = max(dp[j], dp[j - 1]);
        // 下轮遍历 j + 1， pre 就是 dp[i+1][j-1] 了
        pre = temp;
    }
}
```

可能有点抽象，再举个例子:  
比如 j 索引从 1 变为 2 时，一维数组中初始化 base case 已经占满了 1,  
当遍历索引 1 时, 先把索引 1 的值用 temp 存住, 然后索引 1 会被新的值 new 去覆盖掉,  
遍历到索引 2 时, 需要根据 dp[j-1] 也就是刚刚被覆盖掉后新值 new (原二维 dp[i][j-1]) 和索引 1 之前的值 temp (原二维 dp[i+1][j-1]) 以及 索引 2 被赋值之前的值 dp[j] (原二维 dp[i+1][j])来推导出。如下图 😂(画的有点简约了哈)

![](https://cdn.staticaly.com/gh/yokiizx/picgo@master/img/202210182331990.png)

更简单的，如果 dp[i][j] 只与 dp[i-1][...] 相关，投影到一维上，那更可以压缩状态啦，而且还没有覆盖的问题，只是滚动数组需要注意下遍历方向，有时候存在维度的遍历顺序会相反，比如 dp[j] 依赖于 dp[j-1]时，如果正序遍历，dp[j-1]会被新的值给覆盖，这就不对了，所以倒着来就好了。

以上是状态压缩的思路，还是需要多多实践。如有不对，请指教。
