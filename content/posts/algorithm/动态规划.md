---
title: '动态规划'
date: 2022-10-12T09:31:28+08:00
tags: [algorithm, dynamic pogramming]
---

动态规划是算法中比较有意思的东西，在我看来它的核心就是推理，由表象找到内在，再由小推理至结果。

## 三要素：

- 重叠子问题
- 最优子结构
- 状态转移方程

以上三点，单是说怕是不能很好的理解，做了一些题后就会有更好的领悟

> 关于第三点是动态规划的灵魂，贪心算法相比动规就是没有递推的过程，直接局部最优

下方是 labuladong 大佬给出的动态规划的两种方式，重在递归、递推的思路，不是照搬模板哦~

```JavaScript
// 思路1: 自顶向下的动态规划 (递归)
function dp(staus1, ...other_staus) {
  for (const 选择 of 所有可能的选择) {
    // 状态因为选择而发生了改变
    result = 求最值(result, dp(status1, ...otherStatus))
  }
  return result
}

// 思路2: 自底向上的动态规划 (递推)
const dp[0][0][...maybe] = base case
for(const 状态1 of 状态1中的所有取值) {
  for(const 状态2 of 状态2中的所有取值) {
    //...其他状态for循环
    dp[状态1][状态2][...] = 求最值(选择1，选择2...)
  }
}
```

---

## 五部曲

我们平时解决问题，可能最常用的还是下面几个步骤，

1. 确定 dp 数组以及下标的含义 -- 寻找状态与选择
2. dp 数组初始化 -- 依据题目或者边界条件
3. 确定递推公式 -- dp[i] 与 i 的关系很重要
4. 确定遍历顺序 -- 根据递归公式来判断,可以画二位宫格图来看
5. 举例推导 dp 数组 -- 便于遇见问题，打印 dp 验证

> 辅助写出状态转移方程：  
> 明确「状态」-> 明确「选择」 -> 定义 dp 的含义(数组或函数)，最后思考下 base case。

## 实战

##### [70.爬楼梯](https://leetcode.cn/problems/climbing-stairs/)

```JavaScript
/**
 * @param {number} n
 * @return {number}
 */
var climbStairs = function(n) {
    // 1. 定义 dp[i]: 表示爬到第 i 层时的方法数为 dp[i]，第n层 索引为 n + 1
    // 所以初始化为 Array(n + 1)
    const dp = new Array(n + 1).fill(0)
    // 2. 根据题 初始化
    dp[1] = 1
    dp[2] = 2
    // 3. 确定递归公式, 到达第 i 层，可以从i-1层或i-2层进入,
    // 所以方法数为这两种到达第i层的和: dp[i-1] + dp[i-2]
    // 4. 由于i 依赖于 i-1,i-2 所以要从前往后遍历
    for(let i = 3; i < dp.length; ++i) {
        dp[i] = dp[i-1] + dp[i-2]
    }
    return dp[n]
};
```

##### [746.使用最小花费爬楼梯](https://leetcode.cn/problems/min-cost-climbing-stairs/)

```JavaScript
/**
 * @param {number[]} cost
 * @return {number}
 */
var minCostClimbingStairs = function(cost) {
    // 1. 定义dp[i]: 表示到达第 i 层花费的最小值, 要求的是 dp[cost.length]
    // 所以定义 dp 容量为 cost.length + 1
    const n = cost.length
    const dp = new Array(n + 1).fill(0)
    // 2. 初始化 根据题 可以从 0 或 1 下标开始 dp[0]=dp[1]=0
    dp[0] = 0
    dp[1] = 0
    // 3. 公式 dp[i] = min(dp[i-1] + cost[i-1], dp[i-2] + cost[i-2])
    for(let i = 2; i <= n; ++i) {
        dp[i] = Math.min(dp[i-1] + cost[i-1], dp[i-2] + cost[i-2])
    }
    return dp[n]
};
```

> 上方两种题比较，70 题是过程中推到，相对容易；746 题是目标极值推导，对于新手而言要相对难一点，当然了，如果对动规每个细节都烂熟于心，那都很 easy 啦~👻

---

##### [62.不同路径](https://leetcode.cn/problems/unique-paths/)

有点算法基础的人，回过头来再看这道题，乍一看，是不是好像要用回溯或者 dfs？  
--还真可以，但是！时间复杂度将是指数级的！(将一个 2\*2 的矩阵转为二叉树就能很容易理解了，就是求叶子节点的个数)
我的感觉是（不一定对哈，欢迎留言讨论），题目出给了提示：只能向右或向下，这是在提示我们可以做「选择」，那么就可以联想到用动态规划去做了。👻

```JavaScript
/**
 * @param {number} m
 * @param {number} n
 * @return {number}
 */
var uniquePaths = function(m, n) {
    // 1. 定义dp[i][j]: 表示从matrix[0][0]到达 matrix[i][j]的总共路径
    const dp = Array.from(new Array(m), _ => new Array(n).fill(0))
    // 2. base case i == 0 / j == 0 的边界条件 dp[0][j] = 1 dp[j][0] = 1
    for(let i = 0; i < m; ++i) dp[i][0] = 1
    for(let j = 0; j < n; ++j) dp[0][j] = 1
    // 3. 递推公式 [i][j] 可以从 [i-1][j] 或者 [i][j-1] 来 两者相加即可
    for(let i = 1; i < m; ++i) {
        for(let j = 1; j < n; ++j) {
            dp[i][j] = dp[i-1][j] + dp[i][j-1]
        }
    }
    return dp[m-1][n-1]
};
```

##### [63.不同路径 II](https://leetcode.cn/problems/unique-paths-ii/)

```JavaScript
/**
 * @param {number[][]} obstacleGrid
 * @return {number}
 */
var uniquePathsWithObstacles = function(obstacleGrid) {
    // 定义dp[i][j]: [0][0] 到 [i][j] 的路径总数
    const m = obstacleGrid.length
    const n = obstacleGrid[0].length
    const dp = Array.from(new Array(m), _ => new Array(n).fill(0))
    // base case
    dp[0][0] = obstacleGrid[0][0] === 1 ? 0 : 1
    for(let i = 1; i < m; ++i) dp[i][0] = obstacleGrid[i][0] === 1 ? 0 : dp[i-1][0]
    for(let j = 1; j < n; ++j) dp[0][j] = obstacleGrid[0][j] === 1 ? 0 : dp[0][j-1]
    // 递推公式: 没啥难的,就是考虑一下障碍物嘛
    // dp[i][j] = 0 || dp[i-1][j] + dp[i][j-1]
    for(let i = 1; i < m; ++i) {
        for(let j = 1; j < n; ++j) {
            dp[i][j] = obstacleGrid[i][j] === 1 ? 0 : (dp[i-1][j] + dp[i][j-1])
        }
    }
    return dp[m-1][n-1]
};
```

## 推荐阅读

- [Pascal's Triangle](https://www.mathsisfun.com/pascals-triangle.html)
