---
title: '动态规划'
date: 2022-10-12T09:31:28+08:00
tags: [algorithm, dynamic pogramming]
---

动态规划是算法中比较有意思的东西，在我看来它的核心就是推理，由表象找到内在，再由小推理至结果。

## 三要素：

- 重叠子问题
- 最优子结构
- 状态转移方程

以上三点，单是说怕是不能很好的理解，做了一些题后就会有更好的领悟

> 关于第三点是动态规划的灵魂，贪心算法相比动规就是没有递推的过程，直接局部最优

下方是 labuladong 大佬给出的动态规划的两种方式，重在递归、递推的思路，不是照搬模板哦~

```JavaScript
// 思路1: 自顶向下的动态规划 (递归)
function dp(staus1, ...other_staus) {
  for (const 选择 of 所有可能的选择) {
    // 状态因为选择而发生了改变
    result = 求最值(result, dp(status1, ...otherStatus))
  }
  return result
}

// 思路2: 自底向上的动态规划 (递推)
const dp[0][0][...maybe] = base case
for(const 状态1 of 状态1中的所有取值) {
  for(const 状态2 of 状态2中的所有取值) {
    //...其他状态for循环
    dp[状态1][状态2][...] = 求最值(选择1，选择2...)
  }
}
```

---

## 五部曲

我们平时解决问题，可能最常用的还是下面几个步骤，

1. 确定 dp 数组以及下标的含义 -- 寻找状态与选择
2. dp 数组初始化 -- 依据题目或者边界条件
3. 确定递推公式 -- dp[i] 与 i 的关系很重要
4. 确定遍历顺序 -- 根据递归公式来判断,可以画二位宫格图来看
5. 举例推导 dp 数组 -- 便于遇见问题，打印 dp 验证

> 辅助写出状态转移方程：  
> 明确「状态」-> 明确「选择」 -> 定义 dp 的含义(数组或函数)，最后思考下 base case。

## 实战

##### [70.爬楼梯](https://leetcode.cn/problems/climbing-stairs/)

```JavaScript
/**
 * @param {number} n
 * @return {number}
 */
var climbStairs = function(n) {
    // 1. 定义 dp[i]: 表示爬到第 i 层时的方法数为 dp[i]，第n层 索引为 n + 1
    // 所以初始化为 Array(n + 1)
    const dp = new Array(n + 1).fill(0)
    // 2. 根据题 初始化
    dp[1] = 1
    dp[2] = 2
    // 3. 确定递归公式, 到达第 i 层，可以从i-1层或i-2层进入,
    // 所以方法数为这两种到达第i层的和: dp[i-1] + dp[i-2]
    // 4. 由于i 依赖于 i-1,i-2 所以要从前往后遍历
    for(let i = 3; i < dp.length; ++i) {
        dp[i] = dp[i-1] + dp[i-2]
    }
    return dp[n]
};
```

##### [746.使用最小花费爬楼梯](https://leetcode.cn/problems/min-cost-climbing-stairs/)

```JavaScript
/**
 * @param {number[]} cost
 * @return {number}
 */
var minCostClimbingStairs = function(cost) {
    // 1. 定义dp[i]: 表示到达第 i 层花费的最小值, 要求的是 dp[cost.length]
    // 所以定义 dp 容量为 cost.length + 1
    const n = cost.length
    const dp = new Array(n + 1).fill(0)
    // 2. 初始化 根据题 可以从 0 或 1 下标开始 dp[0]=dp[1]=0
    dp[0] = 0
    dp[1] = 0
    // 3. 公式 dp[i] = min(dp[i-1] + cost[i-1], dp[i-2] + cost[i-2])
    for(let i = 2; i <= n; ++i) {
        dp[i] = Math.min(dp[i-1] + cost[i-1], dp[i-2] + cost[i-2])
    }
    return dp[n]
};
```

> 上方两种题比较，70 题是过程中推到，相对容易；746 题是目标极值推导，对于新手而言要相对难一点，当然了，如果对动规每个细节都烂熟于心，那都很 easy 啦~👻
