---
title: '动态规划之打家劫舍'
date: 2022-12-12T11:40:27+08:00
tags: [algorithm]
---

##### [198.打家劫舍](https://leetcode.cn/problems/house-robber/description/)

这道题比较简单，属于比较常规的动态规划，转移方程也比较好写。题目说：“如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。”

- 状态：受影响而持续变化的是 偷到的金钱 --> 受偷房屋索引影响
- 选择：到这个房屋了偷/还是不偷

```JavaScript
/**
 * @param {number[]} nums
 * @return {number}
 */
var rob = function(nums) {
    // 定义 dp[i] 表示 房屋[0..i] 能偷到的最大金额
    const m = nums.length
    const dp = new Array(m).fill(0)
    dp[0] = nums[0]
    dp[1] = Math.max(nums[0], nums[1])
    // dp[i] = max(dp[i-1](不偷这家), dp[i-2] + nums[i](偷这家))
    for(let i = 2; i < m; ++i) {
        dp[i] = Math.max(dp[i-1], dp[i-2] + nums[i])
    }
    return dp[m - 1]
};
```

##### [213.打家劫舍 II](https://leetcode.cn/problems/house-robber-ii/)

与上题类似，唯一的不同是，房屋首尾相连了。

```JavaScript
/**
 * @param {number[]} nums
 * @return {number}
 */
var rob = function(nums) {
    // 首尾相连,意味着只能选一个, 那么就变成了区间[0..m-1) 和[1...m)之间取最大值
    const m = nums.length
    if(m === 1) return nums[0]
    const dp = new Array(m).fill(0)
    dp[0] = nums[0]
    dp[1] = Math.max(nums[0], nums[1])
    // [2..m-1)
    for(let i = 2; i < m - 1; ++i) {
        dp[i] = Math.max(dp[i-1], dp[i-2] + nums[i])
    }
    const max1 = dp[m-2]

    dp[1] = nums[1]
    dp[2] = Math.max(nums[1], nums[2])
    // [3..m)
    for(let i = 3; i < m; ++i) {
        dp[i] = Math.max(dp[i-1], dp[i-2] + nums[i])
    }
    const max2 = dp[m-1]
    return Math.max(max1, max2)
};
```

TODO
