---
title: 'LC2023-array'
date: 2023-05-29T10:37:03+08:00
tags: []
series: ['leetcode2023']
categories: ['leetcode-2023']
---

# 数组

## 数组的遍历

### 485.最大连续 1 的个数

给定一个二进制数组 nums ， 计算其中最大连续 1 的个数。

```js
var findMaxConsecutiveOnes = function (nums) {
  let max = 0,
    count = 0
  for (let i = 0; i < nums.length; i++) {
    if (nums[i] === 1) {
      count++
    } else {
      count = 0 // 其实,也可以在此进行max的更新
      // 但是会丢失最后一个数字为 1 的case,需要在return前加一次更新
    }
    max = Math.max(max, count) // 不断更新max
  }
  return max
}
```

### 495.提莫攻击

```js
/**
 * @param {number[]} timeSeries
 * @param {number} duration
 * @return {number}
 */
var findPoisonedDuration = function (timeSeries, duration) {
  let total = 0,
    posionEnd = 0
  for (let i = 0; i < timeSeries.length; ++i) {
    total += duration
    // 减掉重复的区间即可(此处用的开区间,闭区间稍微改造即可)
    if (posionEnd > timeSeries[i]) total -= posionEnd - timeSeries[i]
    posionEnd = timeSeries[i] + duration
  }
  return total
}
```

### 414.第三大的数

第一反应，转为求第 k 大的数，那么可以借助优先队列来完成。但是这里告诉了是第三大，那么维护三个变量或者一个有序集合，就可以解决了。

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var thirdMax = function (nums) {
  let first = (second = third = -Infinity)
  for (let num of nums) {
    if (num > first) {
      third = second
      second = first
      first = num
    } else if (num > second && num < first) {
      third = second
      second = num
    } else if (num > third && num < second) {
      third = num
    }
  }
  return third === -Infinity ? first : third
}
```

### 628.三个数的最大乘积

给你一个整型数组 nums ，在数组中找出由三个数组成的最大乘积，并输出这个乘积。

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var maximumProduct = function (nums) {
  // 要么三个最大的正数
  // 要么两个最小的负数和最大的正数
  nums.sort((a, b) => a - b)
  const a = nums[0] * nums[1] * nums[nums.length - 1]
  const b = nums[nums.length - 1] * nums[nums.length - 2] * nums[nums.length - 3]
  return Math.max(a, b)
}
```

---

## 统计数组中的元素

### 645.错误的集合

集合 s 包含从 1 到 n 的整数。不幸的是，因为数据错误，导致集合里面某一个数字复制了成了集合里面的另外一个数字的值，导致集合 丢失了一个数字 并且 有一个数字重复 。

给定一个数组 nums 代表了集合 S 发生错误后的结果。

请你找出重复出现的整数，再找到丢失的整数，将它们以数组的形式返回。

输入：nums = [1,2,2,4]
输出：[2,3]

```js
// 用hash表比较好理解,用位运算可以优化空间复杂度,见官解
var findErrorNums = function (nums) {
  const n = nums.length
  const map = {}
  for (const num of nums) {
    if (!map[num]) {
      map[num] = 1
    } else {
      map[num]++
    }
  }
  const res = []
  for (let i = 1; i <= n; ++i) {
    if (map[i] > 1) res[0] = i
    if (!map[i]) res[1] = i
  }
  return res
}
```

### 697.数组的度

给定一个非空且只包含非负数的整数数组 nums，数组的 度 的定义是指数组里任一元素出现频数的最大值。

你的任务是在 nums 中找到与 nums 拥有相同大小的度的最短连续子数组，返回其长度。

```js
var findShortestSubArray = function (nums) {
  // 先用hash表找出度 再去原数组中找最短的
  const map = {}
  for (const num of nums) {
    if (!map[num]) map[num] = 1
    else map[num]++
  }
  let max = []
  let maxCount = 0
  for (const [key, value] of Object.entries(map)) {
    if (value > maxCount) {
      max = [key]
      maxCount = value
    } else if (value === maxCount) {
      max.push(key)
    }
  }
  let minLen = Infinity
  for (const key of max) {
    const start = nums.indexOf(+key) // 注意转成数字
    const end = nums.lastIndexOf(+key)
    const len = end - start + 1
    if (len < minLen) minLen = len
  }
  return minLen
}
```

### 448. 找到所有数组中消失的数字

这道题本身很简单，但是进阶做法是不使用额外空间且时间复杂度为 O(n)，那就需要一定的**技巧**了。

```js
var findDisappearedNumbers = function (nums) {
  // const n = nums.length
  // const res = []
  // for (let i = 1; i <= n; ++i) {
  //   if (!~nums.indexOf(i)) res.push(i)
  // }
  // return res
  /* ---------- O(n)且不使用额外空间 ---------- */
  // 一般这种要求会使用双指针的技巧,或者原地修改原数组来达成目的
  // 遍历每个数字把对应位置重置为负数, 这样最后大于0的数字+1就是消失的数字
  for (const num of nums) {
    nums[Math.abs(num) - 1] = -Math.abs(nums[Math.abs(num) - 1])
  }
  const res = []
  for (let i = 0; i < nums.length; ++i) {
    if (nums[i] >= 0) res.push(i + 1)
  }
  return res
}
```

### 442. 数组中重复的数据(mid)

给你一个长度为 n 的整数数组 nums ，其中 nums 的所有整数都在范围 [1, n] 内，且每个整数出现 一次 或 两次 。请你找出所有出现 两次 的整数，并以数组形式返回。

你必须设计并实现一个**时间复杂度为 O(n) 且仅使用常量额外空间**的算法解决此问题。

```txt
输入：nums = [4,3,2,7,8,2,3,1]
输出：[2,3]
```

```js
var findDuplicates = function (nums) {
  // 和上一题(448)类似, 时间复杂度O(n)空间复杂度O(1) 只能原地修改了
  // tip: 看到数据范围就知道暗示原地哈希, 用正负号做标记
  if (nums.length <= 1) return []
  const res = []
  for (let i = 0; i < nums.length; ++i) {
    const target = Math.abs(nums[i]) - 1 // 可能已经用过了
    if (nums[target] < 0) {
      res.push(target + 1) // 2. 当再次获取值如果为负数表示已经用过了,该位置重复.
    } else {
      nums[target] = -nums[target] // 1. 把该位置变为负数,用以标记已经使用
    }
  }
  return res
}
```

## 数组的改变、移动

## 二维数组及滚动数组

## 数组的旋转

## 特定顺序遍历二维数组

## 二维数组变换

## 前缀和数组

## 差分数组
