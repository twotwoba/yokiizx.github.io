---
title: '0104'
date: 2024-01-04T15:37:23+08:00
lastmod:
tags: []
series: []
categories: []
---

## 简单排序复习 - 冒泡，选择，插入

其中冒泡和选择一定 O(n^2)，插入最坏 O(N^2)，最好 O(N) 取决于数据结构。

```java
// 测试数组
int[] arr = new int[]{2, 1, 5, 9, 5, 4, 3, 6, 8, 9, 6, 7, 3, 4, 2, 7, 1, 8};

/**
 * 交换数组的两个值，此种异或交换值方法的前提是 i != j，否则会变为 0
 */
public static void swap(int[] arr, int i, int j) {
    arr[i] = arr[i] ^ arr[j];
    arr[j] = arr[i] ^ arr[j];
    arr[i] = arr[i] ^ arr[j];
}
```

### 冒泡

```java
/**
 * 冒泡排序
 *
 * @param arr
 */
public static void bubbleSort(int[] arr) {
    for (int i = 0; i < arr.length - 1; i++) {
        boolean sorted = true; // 用于优化 提前终止
        for (int j = 0; j < arr.length - 1 - i; j++) {
            if (arr[j] > arr[j + 1]) {
                swap(arr, j, j + 1);
                sorted = false;
            }
        }
        if (sorted) break;
    }
}
```

### 选择

```java
/**
 * 选择排序
 *
 * @param arr
 */
public static void selectSort(int[] arr) {
    for (int i = 0; i < arr.length - 1; i++) {
        int minIndex = i;
        for (int j = i + 1; j < arr.length; j++) {
            if (arr[j] < arr[minIndex]) {
                minIndex = j;
            }
        }
        if (minIndex != i) {
            swap(arr, minIndex, i);
        }
    }
}
```

### 插入

```java
/**
 * 插入排序
 *
 * @param arr
 */
public static void insertSort(int[] arr) {
    for (int i = 1; i < arr.length; i++) {
        for (int j = i - 1; j >= 0 && arr[j] > arr[j + 1]; --j) {
            swap(arr, j, j + 1);
        }
    }
}
```

## 递归时间复杂度估算

master 公式：`T(N) = a * T(N/b) + O(N^d)`

- T(N): 母问题体量
- T(N/b)：子问题**等量**的体量，a，表示子问题被调了多少次
- O(N^d)：表示其他部分的时间复杂度

1. log(b, a) > d，O(N^log(b,a))
2. log(b, a) = d，O(N^d\*logN)
3. log(b, a) < d，O(N^d)

## 归并排序

分治思想，就是把数看成二叉树，然后从底往上合并（发挥想象力～）。

既然是从底往上合并，想来应该是后序遍历的递归了。

```java
/**
 * 归并排序
 *
 * @param arr
 * @param left
 * @param right
 */
public static void mergeSort(int[] arr, int left, int right) {
    if (left == right) return; // 结束条件
    int mid = left + (right - left >> 1);
    mergeSort(arr, left, mid);
    mergeSort(arr, mid + 1, right);
    merge(arr, left, mid, right);
}

public static void merge(int[] arr, int left, int mid, int right) {
    int[] help = new int[right - left + 1];

    int p1 = left;
    int p2 = mid + 1;
    int i = 0;
    while (p1 <= mid && p2 <= right) {
        help[i++] = arr[p1] < arr[p2] ? arr[p1++] : arr[p2++];
    }
    while (p1 <= mid) {
        help[i++] = arr[p1++];
    }
    while (p2 <= right) {
        help[i++] = arr[p2++];
    }

    for (int j = 0; j < help.length; j++) {
        arr[left + j] = help[j];
    }
}
```

来算下一下时间复杂度吧：根据 master 公式：`T(N) = a * T(N/b) + O(N^d)`，看代码中 mergeSort 内有两个地方调用自己，所以 a == 2，N 被等分了，所以 b == 2，其他地方 merge 函数的时间复杂度是 O(N)，所以 d == 1，那么我们看：log(b,a): `log 以 b 为底 a 的对数`，log(2,2) == 1 == d，所以时间复杂度是：O(N^d \* logN) 即 O(NlogN)。

---

归并排序的思想过程可以帮助解决很多问题，比如小和问题和逆序对问题。

### 小和问题

一个数组中，每一个数左边比当前数小的数加起来的和就是这个数组的小和。比如：[1,3,4,2,5]，小和为：0 + 1 + 4 + 1 + 10 == 16。请你写一个算法求小和。

> 这道题需要转变一下思想：也可以看成每个数右侧有几个比它大：1 \* 4 + 3 \* 2 + 4 \* 1 + 2 \* 1 = 16。那么就可以考虑归并排序啦。

```java
/**
 * 归并排序
 *
 * @param arr
 * @param left
 * @param right
 */
public static int mergeSort(int[] arr, int left, int right) {
    if (left == right) return 0; // 结束条件
    int mid = left + (right - left >> 1);
    return mergeSort(arr, left, mid)
            + mergeSort(arr, mid + 1, right)
            + merge(arr, left, mid, right);
}

public static int merge(int[] arr, int left, int mid, int right) {
    int[] help = new int[right - left + 1];

    int p1 = left;
    int p2 = mid + 1;
    int i = 0;
    int res = 0; // 小和计算
    while (p1 <= mid && p2 <= right) {
        res += arr[p1] < arr[p2] ? arr[p1] * (right - p2 + 1) : 0;  // 关键点
        help[i++] = arr[p1] < arr[p2] ? arr[p1++] : arr[p2++];
    }
    while (p1 <= mid) {
        help[i++] = arr[p1++];
    }
    while (p2 <= right) {
        help[i++] = arr[p2++];
    }

    for (int j = 0; j < help.length; j++) {
        arr[left + j] = help[j];
    }

    return res;
}
```

### 逆序对

一个数组中，左边的数如果比右边的数大，则两个数构成一个逆序对，请打印所有逆序对。这个跟小和问题异曲同工，就不多介绍了。

## 快速排序

### 荷兰国旗问题

荷兰国旗三色，其实就是一个简单的分区问题，一组数，把小于 target 的放一组，等于 target 的放中间，大于 target 的放右边。

要求：额外空间复杂度 O(1)，时间复杂度 O(N)。

```java
/**
 * 荷兰国旗问题，可以想象两个游标卡尺两端往中间挤；
 *
 * @param arr
 * @param target
 */
public static void partition(int[] arr, int target) {
    int l = 0;
    int r = arr.length - 1;

    int i = 0;
    while (i <= r) {
        if (arr[i] < target) {
            swap(arr, i, l);
            i++;
            l++;
        } else if (arr[i] == target) {
            i++;
        } else {
            swap(arr, i, r);
            r--;
        }
    }
}
```

### 快速排序实现

荷兰国旗的问题是快速排序的一环。

随机选择一个数作为 pivot，把 < pivot 的放左边， = pivot 的放中间，> pivot 的放右边。这也就是三路快排的基础。

```java
/**
 * 快速排序
 *
 * @param arr
 * @param l
 * @param r
 */
public static void quickSort(int[] arr, int l, int r) {
    if (l < r) {
        // 随机选择一个数，把它作为基准，同时把它和最右边的数交换，然后进行分区
        int pivot = l + (int) (Math.random() * (r - l + 1));
        swap(arr, pivot, r);

        // 返回 荷兰国旗的 <区右边界下一个 和 >区左边界上一个 即等于区域的[左右边界]
        // 意味着：等于区域已经排好序了，对剩下的左右区域再分别排序即可
        int[] p = partition(arr, l, r);
        quickSort(arr, l, p[0] - 1);
        quickSort(arr, p[1] + 1, r);
    }
}

/**
 * 快速排序分区 partition 函数
 *
 * @param arr
 * @param l
 * @param r
 * @return 等于pivot的左右边界，闭区间
 */
private static int[] partition(int[] arr, int l, int r) {
    int left = l - 1; // < 区右边界
    int right = r; // > 区左边界，因为 r 位置为基准值

    // l 表示当前数位置
    // 这里 小于 right 的原因是因为此时的 arr[r] 为基准值，不需要参与分区过程中
    // 在分区完毕后，放到正确的位置即可
    while (l < right) {
        if (arr[l] < arr[r]) {
            swap(arr, ++left, l++);
        } else if (arr[l] == arr[r]) {
            l++;
        } else {
            swap(arr, l, --right);
        }
    }

    swap(arr, l, r); // 最终 l == right，基准值归位

    return new int[]{left + 1, right}; // 因为最后r回归到等于它的位置
}
```

## 拓展：异或的运用

### 一组数，只有一个数出现了一次，其他都是偶数次，找出这个数

```java
int[] arr = new int[]{2, 1, 5, 9, 5, 4, 3, 6, 8, 12, 9, 6, 7, 3, 4, 2, 7, 1, 8};

/**
 * 找到唯一数字
 *
 * @param arr
 * @return
 */
public static int findOdd(int[] arr) {
    int res = 0;
    for (int num : arr) {
        res ^= num;
    }
    return res;
}
```

### 进阶：一组数，只有 2 个数出现了一次，其他都是偶数次，找出这 2 个数

```java
/**
 * 因为 a != b, 所以 var 一定不等于 0，整数32位中一定至少有一位是不同的。
 * 又所以：var 一定有一位上是 1，同时———其他偶数项的数在这一位置上也要么是1要么是0
 * 我们可以让这个位置上不同的数去异或，那么最后就能得到一个数，另一个数也就可以通过异或得到了
 *
 * @param arr
 * @return
 */
public static int[] findTwoOdd(int[] arr) {
    int var = 0; // 找到两个单独的数； a^b 的值
    for (int num : arr) {
        var ^= num;
    }

    // 找到最右边的 1  a&(~a + 1)
    int rightOne = var & (~var + 1);

    int a = 0;
    for (int num : arr) {
        if ((rightOne & num) == 0) {
            a ^= num;
        }
    }

    int b = a ^ var;

    return new int[]{a, b};
}
```
