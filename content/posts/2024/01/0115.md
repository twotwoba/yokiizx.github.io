---
title: '0115-二叉树'
date: 2024-01-15T21:01:56+08:00
lastmod:
tags: []
series: []
categories: []
---

## 二叉树

```java
class Node<V> {
  V value;
  Node left;
  Node right;
}
```

### 递归序

```java
/**
 *        1
 *       / \
 *      2   3
 *     / \ / \
 *    4  5 6  7
 *
 * 下方 go 函数就是对这棵二叉树的递归序遍历
 * 每个节点都会结果 3 次，分别在1，2，3位置；实际遍历顺序：
 *
 * 1(1)，2(1)，4(1)，4(2)，4(3)，
 * 2(2)，5(1)，5(2)，5(3)，2(3)，
 * 1(2)，3(1)，6(1)，6(2)，6(3)，
 * 3(2)，7(1)，7(2)，7(3)，3(3)，1(3)
 *
 * 前序（根左右（1））结果：1，2，4，5，3，6，7
 * 前序（左根右（2））结果：4，2，5，1，6，3，7
 * 前序（左右根（3））结果：4，5，2，6，7，3，1
 */
public void go(Node head) {
  if(head == null) return;
  // 1
  go(head.left);
  // 2
  go(head.right);
  // 3
}
```

### 前/中/后序遍历

#### 递归

递归方法比较好理解，前中后序就是分别在上方 1，2，3 对应的位置访问(打印等操作)节点。

```java
public void traverse(Node head) {
  if(head == null) return;
  System.out.println(head.val); // 前序遍历
  traverse(head.left);
  System.out.println(head.val); // 中序遍历
  traverse(head.right);
  System.out.println(head.val); // 后序遍历
}
```

```java
// 距离 lc.144
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> list = new ArrayList<>();
        if (root == null) return list;
        traverse(root, list);
        return list;
    }

    public void traverse(TreeNode root, List list) {
        if (root == null) return;
        list.add(root.val);
        traverse(root.left, list);
        traverse(root.right, list);
    }
}
```

#### 迭代

递归转成迭代，核心就是要自己模拟出栈。

##### 前 lc.144

```java
public List<Integer> preorderTraversal(TreeNode root) {
    List<Integer> list = new ArrayList<>();
    if (root == null) return list;
    Stack<TreeNode> stack = new Stack<>();
    stack.push(root);
    while (!stack.empty()) {
        TreeNode top = (TreeNode) stack.pop();
        list.add(top.val);
        if (top.right != null) stack.push(top.right);
        if (top.left != null) stack.push(top.left);
    }
    return list;
}
```

> java 的 Stack 是 Vector 的一个子类  
> java 的 Queue 是由 LinkedList 类实现了 Queue 接口

##### 中 lc.95

```java
public List<Integer> inorderTraversal(TreeNode root) {
    List<Integer> list = new ArrayList<>();
    if (root == null) return list;
    Stack<TreeNode> stack = new Stack<>();
    while (!stack.empty() || root != null) {
        while (root != null) {
            stack.push(root);
            root = root.left;
        }
        TreeNode top = stack.pop();
        list.add(top.val);
        root = top.right;
    }
    return list;
}
```

##### 后 1c.145

- 一种方法是，把前序遍历的 stack 依次出栈时不打印，而是装到另一个栈中，最后对另一个栈依次出栈就是后序遍历的结果
- 另一种方法稍微节约点内存，从上面的二叉树递归序我们知道每个节点有三次遍历到的情况（1 次进入，1 次从左节点返回，1 次从右节点返回），
  那么，在节点出栈的时候，先判定是否有右节点，如果有的话，就先别出栈了，把右节点入栈；问题是当从右节点再回到这个节点的时候，
  就需要一个额外变量来确定右侧的节点是否已经访问过了。

```java
public List<Integer> postorderTraversal(TreeNode root) {
    List<Integer> list = new ArrayList<>();
    if (root == null) return list;
    Stack<TreeNode> stack = new Stack<>();
    TreeNode visited = null;
    while (!stack.empty() || root != null) {
        while (root != null) {
            stack.push(root);
            root = root.left;
        }
        TreeNode top = stack.pop();
        if (top.right == null || top.right == visited) {
            list.add(top.val);
            visited = top;
        } else {
            stack.push(top);
            root = top.right;
        }
    }
    return list;
}
```

### 层序遍历 lc.102

想要实现层序遍历的方法非常多，DFS 也可以，只不过一般不这么用，需要掌握的是 BFS。BFS 的应用非常广泛，其中包括寻找图中的最短路径、解决迷宫问题、树的层序遍历等等。

在遍历过程中，BFS 使用队列来存储已经访问的节点，以确保按照广度优先的顺序进行遍历。

```java
/**
 * 如果只是对逐层从上到下从左到右打印出节点，是很容易的，一个queue就解决了。
 * 但是lc102是要返回形如 [[1],[2,3],...] 这样List<List<Integer>>的数据结构，那么就需要两个队列了
 * 当然，（也有更省空间的方法，双指针记住每一层的结尾节点）
 */
public List<List<Integer>> levelOrder(TreeNode root) {
    List<List<Integer>> list = new ArrayList<>();
    if (root == null) return list;
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    while (!queue.isEmpty()) {
        List<Integer> level = new ArrayList<>();
        int size = queue.size(); // 因为queue在变化，所以需要缓存一下size。当然也可以用两个队列，不断交换来实现，那我个人觉得这种方式更好一点。
        for (int i = 0; i < size; i++) {
            TreeNode top = queue.poll();
            level.add(top.val);
            if (top.left != null) queue.offer(top.left);
            if (top.right != null) queue.offer(top.right);
        }
        list.add(level);
    }
    return list;
}
```

> 以上都是考验的基础硬编码能力，没什么难的，就是要多练。

---
