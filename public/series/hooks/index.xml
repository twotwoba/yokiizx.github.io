<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>Hooks - 系列 - Hello World</title>
        <link>http://localhost:1313/series/hooks/</link>
        <description>Hooks - 系列 - Hello World</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>ericyuanovo@gmail.com (EricYuan)</managingEditor>
            <webMaster>ericyuanovo@gmail.com (EricYuan)</webMaster><lastBuildDate>Tue, 25 Jul 2023 11:47:25 &#43;0800</lastBuildDate><atom:link href="http://localhost:1313/series/hooks/" rel="self" type="application/rss+xml" /><item>
    <title>React hooks--useState&amp;useReducer</title>
    <link>http://localhost:1313/react_hooks--usestateusereducer/</link>
    <pubDate>Tue, 25 Jul 2023 11:47:25 &#43;0800</pubDate><author>
        <name>EricYuan</name>
    </author><guid>http://localhost:1313/react_hooks--usestateusereducer/</guid>
    <description><![CDATA[useStateReact hooks 的出现一大作用就是让函数具有了 state，进而才能全面的拥抱函数式编程。
函数式编程的好处就是两个字：干净，进而可以很好的实现逻辑复用。
tsx
const [state, setState] = useState(initialState) 心智模型(重要)在函数组件中所有的状态在一次渲染中实际上都是不变的，是静态的，你所能看到的 setState 引起的渲染其实已经是下一次渲染了。理解这一点尤为重要，感谢 Dan 的文章讲解。
tsx
const [number, setNumber] = useState(0) const plus = () =&gt; { setNumber(number + 1) setNumber(number + 1) setNumber(number + 1) console.log(&#39;plus ---&#39;, number) // 输出仍然为 0, 就像一个快照 } useEffect(() =&gt; { console.log(&#39;effect ---&#39;, number) // 输出为 1，因为setNumber(number + 1) 的number在这次渲染流程中始终都是 0 !!! }, [number]) /* ---------- 如果依赖于前一次的状态那么应该使用函数式写法 ---------- */ const plus = () =&gt; { setNumber((prev) =&gt; prev + 1) // 更新函数 prev 准确的说是pending state setNumber((prev) =&gt; prev + 1) setNumber((prev) =&gt; prev + 1) console.]]></description>
</item></channel>
</rss>
