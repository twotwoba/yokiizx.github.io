<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>Dp - 系列 - Hello World</title>
        <link>http://localhost:1313/series/dp/</link>
        <description>Dp - 系列 - Hello World</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>ericyuanovo@gmail.com (EricYuan)</managingEditor>
            <webMaster>ericyuanovo@gmail.com (EricYuan)</webMaster><lastBuildDate>Wed, 12 Oct 2022 00:31:28 &#43;0800</lastBuildDate><atom:link href="http://localhost:1313/series/dp/" rel="self" type="application/rss+xml" /><item>
    <title>动态规划</title>
    <link>http://localhost:1313/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</link>
    <pubDate>Wed, 12 Oct 2022 00:31:28 &#43;0800</pubDate><author>
        <name>EricYuan</name>
    </author><guid>http://localhost:1313/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</guid>
    <description><![CDATA[动态规划是一种通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法，它不是一种具体的算法，而是一种解决特定问题的方法。
三要素能用动态规划解决的问题，需要满足三个条件：
最优子结构 子问题重叠 无后效性 练习 70.爬楼梯/** * @param {number} n * @return {number} */ var climbStairs = function (n) { // 1. 定义 dp[i]: 表示爬到第 i 层时的方法数为 dp[i]，第n层 索引为 n + 1 // 所以初始化为 Array(n + 1) const dp = new Array(n + 1).fill(0) // 2. 根据题 初始化 dp[1] = 1 dp[2] = 2 // 3. 确定递归公式, 到达第 i 层，可以从i-1层或i-2层进入, // 所以方法数为这两种到达第i层的和: dp[i-1] + dp[i-2] // 4. 由于i 依赖于 i-1,i-2 所以要从前往后遍历 for (let i = 3; i &lt; dp.]]></description>
</item></channel>
</rss>
