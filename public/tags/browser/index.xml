<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>Browser - 标签 - Hello World</title>
        <link>http://localhost:1313/tags/browser/</link>
        <description>Browser - 标签 - Hello World</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>ericyuanovo@gmail.com (EricYuan)</managingEditor>
            <webMaster>ericyuanovo@gmail.com (EricYuan)</webMaster><lastBuildDate>Thu, 06 Oct 2022 23:29:05 &#43;0800</lastBuildDate><atom:link href="http://localhost:1313/tags/browser/" rel="self" type="application/rss+xml" /><item>
    <title>XSS和CSRF</title>
    <link>http://localhost:1313/xss%E5%92%8Ccsrf/</link>
    <pubDate>Thu, 06 Oct 2022 23:29:05 &#43;0800</pubDate><author>
        <name>EricYuan</name>
    </author><guid>http://localhost:1313/xss%E5%92%8Ccsrf/</guid>
    <description><![CDATA[XSS 和 CSRF 问题是很基础、传统的安全问题，本文不做安全拓展，仅学习这两个知识点，对安全感兴趣的大佬，各种“帽子”书看起来 😄。
专业的话术请见参考，我个人喜欢用土话，起码我自己能理解的话来学习这两个知识点。
XSS - Cross Site Script顾名思义，跨站脚本攻击。
说白了 &mdash; 就是想方设法把恶意脚本搞到你的网页上，脚本执行后获取敏感信息，如 cookie，session id 等。
XSS 分类 存储型：攻击者通过发帖，评论等方式把恶意代码提交到数据库中，用户打开网站后恶意代码从数据库中取出并拼接到 HTML 中返回，浏览器接收后执行执行。 反射型：攻击者构造包含恶意代码的 url，用户打开后(发起请求或跳转页面)，把恶意代码从 url 中取出并拼接到 HTML 中返回，浏览器接收后执行。 // 比如: http://xxx/search?keyword=&#34;&gt;&lt;script&gt;alert(&#39;XSS&#39;);&lt;/script&gt; http://xxx/?redirect=%20javascript:alert(&#39;XSS&#39;) DOM 型：攻击者构造包含恶意代码的 url，用户打开后，浏览器直接解析恶意代码，发起攻击。比如直接使用 document.write()、.innerHTML 这种不安全的 api。 前两个属于服务端的安全漏洞，往往也是服务端渲染，DOM 型属于纯前端的安全漏洞，即取出和执行恶意代码都是由浏览器端完成。
XSS 预防对症下药：
存储型和反射型的 XSS 如果不需要 SEO 的网站，完全可以做前后端分离 如果需要 SEO，那么还是服务端渲染，就需要对 HTML 进行转义 DOM 型 XSS 在使用 .innerHTML、.outerHTML、document.write() 时要特别小心，不要把不可信的数据作为 HTML 插到页面上，而应尽量使用 .textContent、.setAttribute() 等 vue/react 不 v-html/dangerouslySetInnerHTML，使用替代方案 其他预防措施：
HTTP 头：Set-Cookie: HttpOnly，禁止脚本读取敏感 cookie
验证码，防止脚本冒充用户提交危险操作]]></description>
</item><item>
    <title>浏览器和http缓存</title>
    <link>http://localhost:1313/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/</link>
    <pubDate>Thu, 06 Oct 2022 23:19:05 &#43;0800</pubDate><author>
        <name>EricYuan</name>
    </author><guid>http://localhost:1313/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/</guid>
    <description><![CDATA[缓存不论是在前端还是后端，都是一个重要的性能优化手段。
Web 缓存种类： 数据库缓存，CDN 缓存，代理服务器缓存，浏览器缓存。
浏览器缓存的作用：每次发起 http 请求时，会先去检查浏览器缓存中是否有该请求的结果及缓存标识，如果可以使用就直接用了，就不用再去向服务器发起请求了，这样就能节约带宽，缓解服务器压力，提升前端性能；如果浏览器缓存没有或已过期再去向服务器请求，然后根据响应的缓存标识看看是否需要缓存。
缓存过程 强缓存缓存生效直接用浏览器缓存，不向服务器发起请求，返回状态码 200。
关键响应头：
cache-control: max-age=2592000
是 http1.1 字段，优先级比 expires 高。主要有以下几个值： public: 资源客户端和服务器都可以缓存 privite: 只有客户端可以缓存 no-cache: 客户端缓存资源，但是是否缓存需要经过协商缓存来验证 no-store: 不用缓存 max-age=: 缓存保质期 expires: Wed, 21 Oct 2015 07:28:00 GMT
是 http1.0 字段，指定过期日期。缺点是判断是否过期是用本地时间来判断的，本地时间是可以自己修改的。 浏览器遇见以上两个响应头时，就会把资源缓存到 memory cache 或 disk cache 中。
存存储图像和网页等资源主要缓存在 disk cache，操作系统缓存文件等资源大部分都会缓存在 memory cache 中。具体操作浏览器自动分配，看谁的资源利用率不高就分给谁。
协商缓存协商缓存就是强缓存失效后，浏览器携带缓存标识向服务器发送请求，由服务器根据缓存标识来决定是否使用缓存的过程。缓存生效，返回 304。
关键响应头：
last-modified: Wed, 19 Oct 2022 09:54:33 GMT
资源文件在服务器最后被修改的时间。 etag: &ldquo;634fc959-13ad03&rdquo;
当前资源文件的一个唯一标识(由服务器生成) 关键请求头:
if-modified-since: Wed, 19 Oct 2022 09:54:33 GMT]]></description>
</item><item>
    <title>从输入url到页面加载完成</title>
    <link>http://localhost:1313/%E8%BE%93%E5%85%A5url%E5%88%B0%E6%B8%B2%E6%9F%93/</link>
    <pubDate>Thu, 22 Sep 2022 15:33:19 &#43;0800</pubDate><author>
        <name>EricYuan</name>
    </author><guid>http://localhost:1313/%E8%BE%93%E5%85%A5url%E5%88%B0%E6%B8%B2%E6%9F%93/</guid>
    <description><![CDATA[ 经典面试这是一道非常经典的面试题，也是每一个前端都必须掌握的基础知识。对每一个阶段了如指掌会帮助我们进行更好的性能优化。
下面是一个常见的图：`
加餐&ndash;现代浏览器架构 参考 Chrome 浏览器架构 Inside look at modern web browser 从输入URL到页面加载的过程？如何由一道题完善自己的前端知识体系 ]]></description>
</item></channel>
</rss>
