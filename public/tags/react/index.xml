<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>React - 标签 - Hello World</title>
        <link>http://localhost:1313/tags/react/</link>
        <description>React - 标签 - Hello World</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>ericyuanovo@gmail.com (EricYuan)</managingEditor>
            <webMaster>ericyuanovo@gmail.com (EricYuan)</webMaster><lastBuildDate>Wed, 30 Nov 2022 11:59:50 &#43;0800</lastBuildDate><atom:link href="http://localhost:1313/tags/react/" rel="self" type="application/rss+xml" /><item>
    <title>React基础原理9 - Lane模型</title>
    <link>http://localhost:1313/react%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%869-lane%E6%A8%A1%E5%9E%8B/</link>
    <pubDate>Wed, 30 Nov 2022 11:59:50 &#43;0800</pubDate><author>
        <name>EricYuan</name>
    </author><guid>http://localhost:1313/react%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%869-lane%E6%A8%A1%E5%9E%8B/</guid>
    <description><![CDATA[React 与 Scheduler 是两套不同的优先级机制。它们之间是可以转换的lanePriorityToSchedulerPriority/schedulerPriorityToLanePriority。
React 的优先级机制需要满足以下情况：
可以表示优先级的不同 可以表示 批 的概念，因为可能同时存在几个同优先级的更新 便于进行优先级相关计算 针对第一点，React 采用一个 31 位二进制数来表示优先级，如 lane:行车道 的意思一样，每一个位置都表示一条行车道，位数越低，优先级越高 针对第二点，有些优先级同时占用好几条车道，依次来表示批
export const NoLanes: Lanes = /* */ 0b0000000000000000000000000000000; export const NoLane: Lane = /* */ 0b0000000000000000000000000000000; export const SyncLane: Lane = /* */ 0b0000000000000000000000000000001; export const SyncBatchedLane: Lane = /* */ 0b0000000000000000000000000000010; export const InputDiscreteHydrationLane: Lane = /* */ 0b0000000000000000000000000000100; const InputDiscreteLanes: Lanes = /* */ 0b0000000000000000000000000011000; const InputContinuousHydrationLane: Lane = /* */ 0b0000000000000000000000000100000; const InputContinuousLanes: Lanes = /* */ 0b0000000000000000000000011000000; export const DefaultHydrationLane: Lane = /* */ 0b0000000000000000000000100000000; export const DefaultLanes: Lanes = /* */ 0b0000000000000000000111000000000; const TransitionHydrationLane: Lane = /* */ 0b0000000000000000001000000000000; const TransitionLanes: Lanes = /* */ 0b0000000001111111110000000000000; const RetryLanes: Lanes = /* */ 0b0000011110000000000000000000000; export const SomeRetryLane: Lanes = /* */ 0b0000010000000000000000000000000; export const SelectiveHydrationLane: Lane = /* */ 0b0000100000000000000000000000000; const NonIdleLanes = /* */ 0b0000111111111111111111111111111; export const IdleHydrationLane: Lane = /* */ 0b0001000000000000000000000000000; const IdleLanes: Lanes = /* */ 0b0110000000000000000000000000000; export const OffscreenLane: Lane = /* */ 0b1000000000000000000000000000000; 从 SyncLane 往下一直到 SelectiveHydrationLane，赛道的优先级逐步降低。]]></description>
</item><item>
    <title>React基础原理8 - Scheduler</title>
    <link>http://localhost:1313/react%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%868-scheduler/</link>
    <pubDate>Mon, 28 Nov 2022 23:23:21 &#43;0800</pubDate><author>
        <name>EricYuan</name>
    </author><guid>http://localhost:1313/react%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%868-scheduler/</guid>
    <description><![CDATA[Concurrent 模式是一组 React 的新功能，可帮助应用保持响应，并根据用户的设备性能和网速进行适当的调整。
Fiber: 架构将单个组件作为 工作单元，使以组件为粒度的“异步可中断的更新”成为可能 Scheduler: 配合 时间切片，为每个工作单元分配一个 可运行时间，实现“异步可中断的更新” lane 模型: 控制不同 优先级 之间的关系与行为。比如多个优先级之间如何互相打断？优先级能否升降？本次更新应该赋予什么优先级？ 从源码层面讲，Concurrent Mode 是一套可控的“多优先级更新架构”。
Scheduler主要两个功能：
时间切片 优先级调度 时间切片先回顾一下，浏览器的事件循环机制(简约版)：
MacroTask --&gt; MicroTask--&gt; requestAnimationFrame--&gt; 浏览器重排 / 重绘--&gt; requestIdleCallback 时间切片的本质：就是模拟实现：requestIdleCallback，在当前帧还有空余时间时，执行回调。
时间切片选择使用 MessageChannel 实现，它的执行时机比 setTimeout 更靠前。
// Scheduler 将需要被执行的回调函数作为 MessageChannel 的回调执行 const channel = new MessageChannel(); const port = channel.port2; channel.port1.onmessage = performWorkUntilDeadline; requestHostCallback = function(callback) { scheduledHostCallback = callback; if (!isMessageLoopRunning) { isMessageLoopRunning = true; port.postMessage(null); } }; // 如果不支持 MessageChannel 会降级成 setTimeout const _flushCallback = function() { if (_callback !]]></description>
</item><item>
    <title>React -- Hooks</title>
    <link>http://localhost:1313/react-hooks/</link>
    <pubDate>Sun, 27 Nov 2022 11:28:43 &#43;0800</pubDate><author>
        <name>EricYuan</name>
    </author><guid>http://localhost:1313/react-hooks/</guid>
    <description><![CDATA[React 需要为共享状态逻辑提供更好的原生途径。Hook 使你在无需修改组件结构的情况下复用状态逻辑 &mdash; React 官网
你可以从 React 的 LOGO 中看到这些围绕着核心的电子飞行轨道，Hooks 可能一直就在其中。 &mdash; Dan
hook 工作原理从 useState 入手：
const [demo, setDemo] = useState({name: &#39;yokiizx&#39;, age: 18}) &lt;div&gt; {demo.name} &lt;button onClick={() =&gt; setDemo({age: 35})}&gt; &lt;/div&gt; 组件更新 useState 的工作主要分为两种：
mount：调用 ReactDOM.render/ReactDOM.createRoot().render() 引起的更新，更新内容为 初始化值 update：setXxx 引起的更新，更新内容为 setXxx 创建的 Update。 Update重点之一是 Update，这个在之前学习过：HostRoot 和 ClassComponent 共用一套 Update 数据结构，回顾一下：
export type Update&lt;State&gt; = {| eventTime: number, // 任务时间，通过performance.now()获取的毫秒数 lane: Lane, // 优先级相关字段 tag: 0 | 1 | 2 | 3, // 四种更新类型 UpdateState | ReplaceState | ForceUpdate | CaptureUpdate payload: any, // 更新挂载的数据:ClassComponent挂载的this.]]></description>
</item><item>
    <title>React基础原理 - setState</title>
    <link>http://localhost:1313/react-setstate/</link>
    <pubDate>Wed, 23 Nov 2022 09:30:25 &#43;0800</pubDate><author>
        <name>EricYuan</name>
    </author><guid>http://localhost:1313/react-setstate/</guid>
    <description><![CDATA[触发状态更新，前面说了五种：
ReactDOM.render —— HostRoot this.setState —— ClassComponent this.forceUpdate —— ClassComponent useState —— FunctionComponent useReducer —— FunctionComponent 今天重点说一下 setState：
setState 最终调用的是 this.updater.enqueueSetState(this, partialState, callback, 'setState')。
首先要明确一点，针对 React 中的 state，不像 vue 那样，是没有做任何数据绑定的，当 state 发生变化时，是发生了一次重新渲染，每一次渲染都能拿到独立的 state 状态，这个状态值是函数中的一个常量。
const classComponentUpdater = { isMounted, enqueueSetState(inst, payload, callback) { // 通过组件实例获取对应 fiber const fiber = getInstance(inst); const eventTime = requestEventTime(); // 获取优先级 const lane = requestUpdateLane(fiber); // 创建 update 对象 把 payload 和 callback 添加到 update 对象上 const update = createUpdate(eventTime, lane); update.]]></description>
</item><item>
    <title>React基础原理7 - Diff算法</title>
    <link>http://localhost:1313/react%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%867-diff%E7%AE%97%E6%B3%95/</link>
    <pubDate>Tue, 22 Nov 2022 17:15:07 &#43;0800</pubDate><author>
        <name>EricYuan</name>
    </author><guid>http://localhost:1313/react%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%867-diff%E7%AE%97%E6%B3%95/</guid>
    <description><![CDATA[在 render 阶段的 beginWork 如果是 update 最终走入 reconcileChildFibers，这个方法就是通过 diff 算法创建新 Fiber 并加上 flags，并尝试复用 currentFiber。
本文学习一下 React 的 diff 算法。
diff 算法的本质是：JSX 对象和 current Fiber 对比，生成 workInProgress Fiber。
三个限制首先，两棵树完全对比的时间复杂度是 O(n^3)，是相当消耗性能的，为此，React 的 diff 算法预设了 3 个限制：
只对同级元素进行 diff。如果 DOM 节点前后两次更新跨越了层级，不会复用它。 不同类型的元素产生不同的树。如果 DOM 节点前后两次更新类型发生了变，会直接销毁它及子节点，并重新建树。 可以通过 key 标识哪些子元素在不同的渲染中可能是不变的。 reconcileChildFibersfunction reconcileChildFibers( returnFiber: Fiber, currentFirstChild: Fiber | null, newChild: any, lanes: Lanes ): Fiber | null { // 获取 newChild 类型 (JSX对象) const isObject = typeof newChild === &#39;object&#39; &amp;&amp; newChild !]]></description>
</item><item>
    <title>React基础原理6 - commit 阶段</title>
    <link>http://localhost:1313/react%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%866/</link>
    <pubDate>Thu, 17 Nov 2022 10:57:23 &#43;0800</pubDate><author>
        <name>EricYuan</name>
    </author><guid>http://localhost:1313/react%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%866/</guid>
    <description><![CDATA[render 通过 commitRoot(root) 进入此阶段。该阶段调用的主函数是 commitRootImpl(root, renderPriorityLevel)。
此时，rootFiber.firstEffect 上保存了一条需要执行副作用的 Fiber 节点的单向链表 effectList，这些 Fiber 节点的 updateQueue 上保存着变化了的 props。
这些副作用的 DOM 操作在 commit 阶段执行。
commit 阶段主要分为：before mutation，mutation，layout 这三个阶段。
开始三个阶段之前先看下 commitRootImpl 的主要内容：
// 保存之前的优先级，以同步优先级执行，执行完毕后恢复之前优先级 const previousLanePriority = getCurrentUpdateLanePriority(); setCurrentUpdateLanePriority(SyncLanePriority); // 将当前上下文标记为CommitContext，作为commit阶段的标志 const prevExecutionContext = executionContext; executionContext |= CommitContext; // 处理focus状态 focusedInstanceHandle = prepareForCommit(root.containerInfo); shouldFireAfterActiveInstanceBlur = false; before muatation(执行 DOM 操作前)遍历 effectList，进入主函数 commitBeforeMutationEffects：
function commitBeforeMutationEffects() { while (nextEffect !== null) { const current = nextEffect.alternate if (!]]></description>
</item><item>
    <title>React基础原理5 - render 阶段</title>
    <link>http://localhost:1313/react%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%865/</link>
    <pubDate>Mon, 14 Nov 2022 17:06:21 &#43;0800</pubDate><author>
        <name>EricYuan</name>
    </author><guid>http://localhost:1313/react%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%865/</guid>
    <description><![CDATA[从创建 FiberRoot，到创建 Update，再遍历到 FiberRoot，然后发起一个 task，进入到了 performSyncWorkOnRoot或performConcurrentWorkOnRoot 方法中，这便是 render 阶段的开端。
这两个方法又分别调用了 renderRootSync 和 renderRootConcurrent（这两个方法返回 exitStatus 供后续使用），其内部又分别调用了 workLoopSync 和 workLoopConcurrent：
function workLoopSync() { // Already timed out, so perform work without checking if we need to yield. while (workInProgress !== null) { performUnitOfWork(workInProgress); } } function workLoopConcurrent() { // Perform work until Scheduler asks us to yield while (workInProgress !== null &amp;&amp; !shouldYield()) { performUnitOfWork(workInProgress); } } 可以看出这两唯一的区别就是多了一个 shouldYield 的判断，如果当前浏览器帧没有剩余时间，shouldYield 会中止循环，直到浏览器有空闲时间后再继续遍历。
源码中追踪到最后是 throw new Error('This module must be shimmed by a specific build.]]></description>
</item><item>
    <title>React基础原理4 - 获取fiberRoot&amp;调度更新</title>
    <link>http://localhost:1313/react%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%864/</link>
    <pubDate>Mon, 14 Nov 2022 16:33:10 &#43;0800</pubDate><author>
        <name>EricYuan</name>
    </author><guid>http://localhost:1313/react%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%864/</guid>
    <description><![CDATA[上文的 5 种触发更新使得被触发更新的 Fiber 对象上已经记录下了所有需要变化的 Update，那么接下来就是要调用 markUpdateLaneFromFiberToRoot 这个方法。
markUpdateLaneFromFiberToRoot (获取到 fiberRoot)function markUpdateLaneFromFiberToRoot(sourceFiber: Fiber, lane: Lane): FiberRoot | null { // Update the source fiber&#39;s lanes sourceFiber.lanes = mergeLanes(sourceFiber.lanes, lane) let alternate = sourceFiber.alternate if (alternate !== null) { alternate.lanes = mergeLanes(alternate.lanes, lane) } // Walk the parent path to the root and update the child expiration time. let node = sourceFiber let parent = sourceFiber.return while (parent !== null) { parent.]]></description>
</item><item>
    <title>React基础原理3 - Update</title>
    <link>http://localhost:1313/react%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%863/</link>
    <pubDate>Sun, 13 Nov 2022 10:09:22 &#43;0800</pubDate><author>
        <name>EricYuan</name>
    </author><guid>http://localhost:1313/react%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%863/</guid>
    <description><![CDATA[React 工作的整个流程：
触发状态更新 ---&gt; ReactDOM.render()进入updateContainer后/this.setState()调用`this.updater.enqueueSetState` 创建 Update 对象 ---&gt; 从触发更新的fiber回溯到fiberRoot,触发调度 ---&gt; render ---&gt; commit 在 JSX 拥有了 ReactElement，ReactElement 进化为 Fiber 后（render 阶段），就要被渲染进入视野了（commit 阶段）。render 阶段是协调器 Reconciler 发挥作用，commit 阶段是渲染器 Renderer 发挥作用。
但是在 render 阶段之前，我们需要一个阶段，去创建 update 对象。
updateContainer在 render --&gt; legacyRenderSubtreeIntoContainer 方法中，创建完 fiberRoot 后，就会调用 updateContainer 方法，创建 Update 对象，并把 update 加入更新队列，最后调度更新。
export function updateContainer( element: ReactNodeList, container: OpaqueRoot, parentComponent: ?React$Component&lt;any, any&gt;, callback: ?Function ): Lane { // 以下代码与创建 update 逻辑无关 // const current = container.]]></description>
</item><item>
    <title>React基础原理2 - Fiber</title>
    <link>http://localhost:1313/react%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%862/</link>
    <pubDate>Fri, 11 Nov 2022 16:16:15 &#43;0800</pubDate><author>
        <name>EricYuan</name>
    </author><guid>http://localhost:1313/react%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%862/</guid>
    <description><![CDATA[Fiber三大件之一的 Reconciler 在 React16 之后是需要依靠 Fiber 这个数据结构去实现的。
首先 Fiber 自身就是一种数据结构，每个 ReactElement 都对应着一个 Fiber 节点；让 Reconciler 支持任务的不同优先级，可中断与恢复，并且恢复后可以复用之前的 中间状态。
相比 ReactElement，Fiber 存储了对应的组件类型和 DOM 节点等信息，以及本次更新中该组件要改变的状态和要更新的动作。
那么来看看 Fiber 的真实面容：
function FiberNode( tag: WorkTag, pendingProps: mixed, key: null | string, mode: TypeOfMode, ) { /* 作为静态数据结构的属性 */ this.tag = tag; // 标记 Fiber 类型 FunctionComponent/ClassComponent/HostRoot...共25种(17.0.2) this.key = key; // ReactElement 里的 key this.elementType = null; // ReactElement.type，也就是我们调用 createElement 的第一个参数 this.type = null; // 对于 FunctionComponent，指函数本身，对于ClassComponent，指class，对于HostComponent，指DOM节点tagName this.]]></description>
</item></channel>
</rss>
