<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>所有文章 - Hello World</title>
        <link>http://localhost:1313/posts/</link>
        <description>所有文章 | Hello World</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>ericyuanovo@gmail.com (EricYuan)</managingEditor>
            <webMaster>ericyuanovo@gmail.com (EricYuan)</webMaster><lastBuildDate>Wed, 21 Feb 2024 00:00:00 &#43;0000</lastBuildDate><atom:link href="http://localhost:1313/posts/" rel="self" type="application/rss+xml" /><item>
    <title>React hooks--useState&amp;useReducer</title>
    <link>http://localhost:1313/react_hooks--usestateusereducer/</link>
    <pubDate>Tue, 25 Jul 2023 11:47:25 &#43;0800</pubDate><author>
        <name>EricYuan</name>
    </author><guid>http://localhost:1313/react_hooks--usestateusereducer/</guid>
    <description><![CDATA[useStateReact hooks 的出现一大作用就是让函数具有了 state，进而才能全面的拥抱函数式编程。
函数式编程的好处就是两个字：干净，进而可以很好的实现逻辑复用。
tsx
const [state, setState] = useState(initialState) 心智模型(重要)在函数组件中所有的状态在一次渲染中实际上都是不变的，是静态的，你所能看到的 setState 引起的渲染其实已经是下一次渲染了。理解这一点尤为重要，感谢 Dan 的文章讲解。
tsx
const [number, setNumber] = useState(0) const plus = () =&gt; { setNumber(number + 1) setNumber(number + 1) setNumber(number + 1) console.log(&#39;plus ---&#39;, number) // 输出仍然为 0, 就像一个快照 } useEffect(() =&gt; { console.log(&#39;effect ---&#39;, number) // 输出为 1，因为setNumber(number + 1) 的number在这次渲染流程中始终都是 0 !!! }, [number]) /* ---------- 如果依赖于前一次的状态那么应该使用函数式写法 ---------- */ const plus = () =&gt; { setNumber((prev) =&gt; prev + 1) // 更新函数 prev 准确的说是pending state setNumber((prev) =&gt; prev + 1) setNumber((prev) =&gt; prev + 1) console.]]></description>
</item><item>
    <title>Mac上的高效软件与配置</title>
    <link>http://localhost:1313/mac%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E5%92%8C%E6%95%88%E7%8E%87/</link>
    <pubDate>Tue, 13 Sep 2022 11:24:00 &#43;0800</pubDate><author>
        <name>EricYuan</name>
    </author><guid>http://localhost:1313/mac%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E5%92%8C%E6%95%88%E7%8E%87/</guid>
    <description><![CDATA[工欲善其事，必先利其器 🥷
文章取自本人日常使用习惯，不一定适合每个人，如您有更好的提效工具或技巧，欢迎留言 👏🏻
软件推荐 Homebrew官网
懂得都懂，mac 的包管理器，可以直接去官网按照提示安装即可。
安装完成后记得替换一下镜像源，推荐腾讯镜像源。
sh
# 替换brew.git cd &#34;$(brew --repo)&#34; git remote set-url origin https://mirrors.cloud.tencent.com/homebrew/brew.git # 替换homebrew-core.git cd &#34;$(brew --repo)/Library/Taps/homebrew/homebrew-core&#34; git remote set-url origin https://mirrors.cloud.tencent.com/homebrew/homebrew-core.git 如果没有 🪜，可以使用国内大神的脚本傻瓜式安装： sh
# 按照提示操作下去即可 /bin/zsh -c &#34;$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)&#34; oh-my-zsh直接点击官网安装即可。
~/.zshrc 配置文件的部分配置：
sh
# zsh theme；default robbyrussell，prefer miloshadzic ZSH_THEME=&#34;miloshadzic&#34; # plugins plugins=( # 默认的,配置了很多别名 ~/.oh-my-zsh/plugins/git/git.plugin.zsh git # 语法高亮 # https://github.com/zsh-users/zsh-syntax-highlighting/blob/master/INSTALL.md#oh-my-zsh zsh-syntax-highlighting # 输入命令的时候给出提示 # https://github.com/zsh-users/zsh-autosuggestions/blob/master/INSTALL.md#oh-my-zsh zsh-autosuggestions ) # 让terminal标题干净 DISABLE_AUTO_TITLE=&#34;true&#34; 当VsCode终端出现git乱码问题，添加以下代码进 `~/.]]></description>
</item><item>
    <title>Mysql_2_索引和事务</title>
    <link>http://localhost:1313/mysql_2/</link>
    <pubDate>Thu, 07 Dec 2023 16:10:47 &#43;0800</pubDate><author>
        <name>EricYuan</name>
    </author><guid>http://localhost:1313/mysql_2/</guid>
    <description><![CDATA[索引 基础说起提高数据库性能，索引是最物美价廉的东西了。不用加内存，不用改程序，不用调 sql，查询速度就可能提高百倍干倍。
sql
# 给表的某列添加索引 create index index_name on tb_name (tb_col_name); 创建索引后，查询只对创建了索引的列有效，性能提高显著
副作用：
索引自身也是占用空间的，添加索引后，表占用空间会变大 对 DML (insert into, update, delete) 语句有效率影响 (因为需要重新构建索引) 原理 没有索引时：从头到尾全表扫描 创建索引后：存储引擎 innodb，B+树，牺牲空间换时间～ TODO 索引类型 主键索引，主键自动地为主索引 唯一索引，unique 修饰的列 普通索引，index 全文索引，FULLTEXT，一般不用 mysql 自带的全文索引 开发中考虑使用全文搜索 solr，或者 ElasticSearch（即 es） 使用 sql
# 查询是否有索引 SHOW INDEXES FROM tb_name # 创建或修改 create [unique] index index_name on tb_name (col_name [(length)]) alter table tb_name add index index_name (col_name) # 删除索引 drop index index_name on tb_name # 删除主键索引 alter table tb_name drop primary key 场景 一般频繁查询的字段应该创建索引 唯一性太差的字段不适合创建索引 更新非常频繁的字段不适合创建索引 不会出现在 where 子句中的字段不该创建索引 事务事务 用于保证数据的一致性，它由一组 dml 语句组成，该组的 dml 语句，要么全部成功，要么全部失败。&ndash; 比如转账，如果转出成功，转入失败，是很恐怖的事情。这就需要事务确保了。]]></description>
</item><item>
    <title>滑动窗口</title>
    <link>http://localhost:1313/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</link>
    <pubDate>Wed, 21 Feb 2024 00:00:00 &#43;0000</pubDate><author>
        <name>EricYuan</name>
    </author><guid>http://localhost:1313/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</guid>
    <description><![CDATA[核心滑动窗口的核心就是维持一个 [i..j) 的区间窗口，在数据上游走，来获取到需要的信息，在数组,字符串等中的表现，往往如下：
js
function slideWindow() { // 前后快慢双指针 let left = 0 let right = 0 /** 具体的条件逻辑根据实际问题实际处理，多做练习 */ while(slide condition) { window.push(s[left]) // s 为总数据（字符串、数组） right++ while(shrink condition) { window.shift(s[left]) left++ } } } 滑动窗口的算法时间复杂度为 O(n)，适用于处理大型数据集
练一练 lc.3 无重复字符的最长子串 js
/** * @param {string} s * @return {number} */ var lengthOfLongestSubstring = function (s) { let max = 0 let l = 0, r = 0 let window = {} while (r &lt; s.]]></description>
</item><item>
    <title>数组-双指针应用</title>
    <link>http://localhost:1313/%E5%8F%8C%E6%8C%87%E9%92%88/</link>
    <pubDate>Fri, 16 Feb 2024 00:00:00 &#43;0000</pubDate><author>
        <name>EricYuan</name>
    </author><guid>http://localhost:1313/%E5%8F%8C%E6%8C%87%E9%92%88/</guid>
    <description><![CDATA[数组双指针双指针，一般两种，快慢指针和左右指针，根据不同场景使用不同方法。
以下题基本都是简单题，知道使用双指针就没啥难度了~
lc.167 两数之和 II - 有序数组 js
/** * @param {number[]} numbers * @param {number} target * @return {number[]} */ var twoSum = function (numbers, target) { let left = 0, right = numbers.length - 1 while (left &lt; right) { if (numbers[left] + numbers[right] &lt; target) { left++ } else if (numbers[left] + numbers[right] &gt; target) { right-- } else if (numbers[left] + numbers[right] === target) { return [left + 1, right + 1] } } } lc.]]></description>
</item><item>
    <title>前缀树（字典树）</title>
    <link>http://localhost:1313/%E5%89%8D%E7%BC%80%E6%A0%91/</link>
    <pubDate>Tue, 13 Feb 2024 17:54:23 &#43;0800</pubDate><author>
        <name>EricYuan</name>
    </author><guid>http://localhost:1313/%E5%89%8D%E7%BC%80%E6%A0%91/</guid>
    <description><![CDATA[概念及实现前缀树，也叫字典树，就是一种数据结构，比如有一组字符串 ['abc', 'ab', 'bc', 'bck']，那么它的前缀树是这样的：
核心：字符在树的树枝上，节点上保存着信息 (当然不是这么死，个人习惯，程序怎么实现都是 ok 的)，含义如下：
p：通过树枝字符的字符串数量. &ndash; 可以查询前缀数量 e：以树枝字符结尾的字符串数量. &ndash; 可以查询字符串 对应的数据结构如下：
js
class TrieNode { constructor(pass = 0, end = 0) { this.pass = pass // 通过下接树枝字符的字符串数量 this.end = end // 以上接树枝字符结尾的字符串数量 this.next = {} // {char: TrieNode} 的 map 集， 字符有限，有些教程也用数组实现；next 的 key 就可以抽象为树枝 } } class Trie { constructor() { this.root = new TrieNode() } insert(str) { let p = this.root for (const c of str) { if (!]]></description>
</item><item>
    <title>二叉树</title>
    <link>http://localhost:1313/%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
    <pubDate>Mon, 15 Jan 2024 21:01:56 &#43;0800</pubDate><author>
        <name>EricYuan</name>
    </author><guid>http://localhost:1313/%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
    <description><![CDATA[二叉树 java
class Node&lt;V&gt; { V value; Node left; Node right; } 递归序 java
/** * 1 * / \ * 2 3 * / \ / \ * 4 5 6 7 * * 下方 go 函数就是对这棵二叉树的递归序遍历 * 每个节点都会结果 3 次，分别在1，2，3位置；实际遍历顺序： * * 1(1)，2(1)，4(1)，4(2)，4(3)， * 2(2)，5(1)，5(2)，5(3)，2(3)， * 1(2)，3(1)，6(1)，6(2)，6(3)， * 3(2)，7(1)，7(2)，7(3)，3(3)，1(3) * * 前序（根左右（1））结果：1，2，4，5，3，6，7 * 前序（左根右（2））结果：4，2，5，1，6，3，7 * 前序（左右根（3））结果：4，5，2，6，7，3，1 */ public void go(Node head) { if(head == null) return; // 1 go(head.]]></description>
</item><item>
    <title>链表</title>
    <link>http://localhost:1313/%E9%93%BE%E8%A1%A8/</link>
    <pubDate>Tue, 09 Jan 2024 20:10:19 &#43;0800</pubDate><author>
        <name>EricYuan</name>
    </author><guid>http://localhost:1313/%E9%93%BE%E8%A1%A8/</guid>
    <description><![CDATA[链表 java
class Node&lt;V&gt; { V value; Node next; } class Node&lt;V&gt; { V value; Node next; Node last; } 对于链表算法，在面试中，一定尽量用到空间复杂度最小的方法（不然凭啥用咱是吧 🐶）。
链表「换头」情况操作链表出现「换头」的情况，函数的递归调用形式应该是 head = func(head.next)，所以函数在设计的时候就应该有一个 Node 类型的返回值，比如反转链表。
哨兵守卫「哨兵守卫」是链表中的常用技巧。通过在链表头部或尾部添加守卫节点，可以简化对边界情况的处理。
链表中常用的技巧-快慢指针 找到链表的中点、中点前一个、中点后一个这个是硬编码能力，需要大量练习打好基本功。
java
/** * 奇数的中点; 偶数的中点靠前一位 */ Node s = head; Node f = head; while (f.next != null &amp;&amp; f.next.next != null) { s = s.next; f = f.next.next; } /** * 奇数的中点; 偶数的中点靠后一位 lc.876 easy */ while (f !]]></description>
</item><item>
    <title>必须掌握的排序方法&amp;递归时间复杂度</title>
    <link>http://localhost:1313/%E5%BF%85%E6%8E%8C%E6%8F%A1%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</link>
    <pubDate>Thu, 04 Jan 2024 15:37:23 &#43;0800</pubDate><author>
        <name>EricYuan</name>
    </author><guid>http://localhost:1313/%E5%BF%85%E6%8E%8C%E6%8F%A1%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</guid>
    <description><![CDATA[冒泡，选择，插入其中冒泡和选择一定 O(n^2)，插入最坏 O(N^2)，最好 O(N) 取决于数据结构。
java
// 测试数组 int[] arr = new int[]{2, 1, 5, 9, 5, 4, 3, 6, 8, 9, 6, 7, 3, 4, 2, 7, 1, 8}; /** * 交换数组的两个值，此种异或交换值方法的前提是 i != j，否则会变为 0 */ public void swap(int[] arr, int i, int j) { arr[i] = arr[i] ^ arr[j]; arr[j] = arr[i] ^ arr[j]; arr[i] = arr[i] ^ arr[j]; } // 保险还是用这个吧～ public void swap(int[] arr, int i, int j) { int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } 冒泡从左往右，两两比较，冒出极值]]></description>
</item><item>
    <title>Change in 2024</title>
    <link>http://localhost:1313/new_life/</link>
    <pubDate>Wed, 03 Jan 2024 14:33:13 &#43;0800</pubDate><author>
        <name>EricYuan</name>
    </author><guid>http://localhost:1313/new_life/</guid>
    <description><![CDATA[Hello 2024 Well, I have to admit that it is too inefficient to take notes while studying!
so, I give up!
PlanBut I won&rsquo;t stop, I will learn English and Spring Framework quickly this year, and use them in daily life.
Of course, I will do some algorithm if I have time 😏.
good luck to me，peace！]]></description>
</item></channel>
</rss>
